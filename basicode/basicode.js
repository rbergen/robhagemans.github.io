"use strict";

///////////////////////////////////////////////////////////////////////////////
// BASICODE interpreter
// Copyright (c) 2016, 2017 Rob Hagemans
// Licensed under the GNU General Public Licence, version 3
///////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
// For a similar interpreter see https://github.com/MarquisdeGeek/basicode
// which is (c) 2012 by Steven Goodwin and licensed under the GPL
//
// I'd like to acknowledge Steven"s interpreter as a source of inspiration.
// However, this interpreter does not take code from his.


///////////////////////////////////////////////////////////////////////////////
// compatibility/polyfills

// Web Audio API
// Safari still only has the experimental version of the Web Audio API
// not sure if we're not breaking Safari elsewhere, though
window.AudioContext = window.AudioContext || window.webkitAudioContext;

// String repeat method
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/repeat
if (!String.prototype.repeat) {
  String.prototype.repeat = function(count) {
    "use strict";
    if (this == null) {
      throw new TypeError("can\"t convert " + this + " to object");
    }
    var str = "" + this;
    count = +count;
    if (count != count) {
      count = 0;
    }
    if (count < 0) {
      throw new RangeError("repeat count must be non-negative");
    }
    if (count == Infinity) {
      throw new RangeError("repeat count must be less than infinity");
    }
    count = Math.floor(count);
    if (str.length == 0 || count == 0) {
      return "";
    }
    // Ensuring count is a 31-bit integer allows us to heavily optimize the
    // main part. But anyway, most current (August 2014) browsers can't handle
    // strings 1 << 28 chars or longer, so:
    if (str.length * count >= 1 << 28) {
      throw new RangeError("repeat count must not overflow maximum string size");
    }
    var rpt = "";
    for (;;) {
      if ((count & 1) == 1) {
        rpt += str;
      }
      count >>>= 1;
      if (count == 0) {
        break;
      }
      str += str;
    }
    return rpt;
  }
}


///////////////////////////////////////////////////////////////////////////////
// errors

function BasicError(message, detail, location)
{
    this.message = message;
    this.detail = detail;
    this.where = location;
    // capture stack trace, see http://stackoverflow.com/questions/464359/custom-exceptions-in-javascript
    if ("captureStackTrace" in Error) {
        Error.captureStackTrace(this, BasicError);
    }
    else {
        this.stack = (new Error()).stack;
    }
}

BasicError.prototype = Object.create(Error.prototype);
BasicError.prototype.name = "BasicError";
BasicError.prototype.constructor = BasicError;


///////////////////////////////////////////////////////////////////////////////
// bitfonts

var FONTS = {
    "cga": {
        "width": 8,
        "height": 8,
        "glyphs": [
            "0000000000000000", "3078783030003000", "6C6C6C0000000000", "6C6CFE6CFE6C6C00",
            "307CC0780CF83000", "00C6CC183066C600", "386C3876DCCC7600", "6060C00000000000",
            "1830606060301800", "6030181818306000", "00663CFF3C660000", "003030FC30300000",
            "0000000000303060", "000000FC00000000", "0000000000303000", "060C183060C08000",
            "7CC6CEDEF6E67C00", "307030303030FC00", "78CC0C3860CCFC00", "78CC0C380CCC7800",
            "1C3C6CCCFE0C1E00", "FCC0F80C0CCC7800", "3860C0F8CCCC7800", "FCCC0C1830303000",
            "78CCCC78CCCC7800", "78CCCC7C0C187000", "0030300000303000", "0030300000303060",
            "183060C060301800", "0000FC0000FC0000", "6030180C18306000", "78CC0C1830003000",

            "7CC6DEDEDEC07800", "3078CCCCFCCCCC00", "FC66667C6666FC00", "3C66C0C0C0663C00",
            "F86C6666666CF800", "FE6268786862FE00", "FE6268786860F000", "3C66C0C0CE663E00",
            "CCCCCCFCCCCCCC00", "7830303030307800", "1E0C0C0CCCCC7800", "E6666C786C66E600",
            "F06060606266FE00", "C6EEFEFED6C6C600", "C6E6F6DECEC6C600", "386CC6C6C66C3800",
            "FC66667C6060F000", "78CCCCCCDC781C00", "FC66667C6C66E600", "78CC603018CC7800",
            "FCB4303030307800", "CCCCCCCCCCCCFC00", "CCCCCCCCCC783000", "C6C6C6D6FEEEC600",
            "C6C66C38386CC600", "CCCCCC7830307800", "FEC68C183266FE00", "7860606060607800",
            "C06030180C060200", "7818181818187800", "10386CC600000000", "00000000000000FF",

            "3030180000000000", "0000780C7CCC7600", "E060607C6666DC00", "000078CCC0CC7800",
            "1C0C0C7CCCCC7600", "000078CCFCC07800", "386C60F06060F000", "000076CCCC7C0CF8",
            "E0606C766666E600", "3000703030307800", "0C000C0C0CCCCC78", "E060666C786CE600",
            "7030303030307800", "0000CCFEFED6C600", "0000F8CCCCCCCC00", "000078CCCCCC7800",
            "0000DC66667C60F0", "000076CCCC7C0C1E", "0000DC766660F000", "00007CC0780CF800",
            "10307C3030341800", "0000CCCCCCCC7600", "0000CCCCCC783000", "0000C6D6FEFE6C00",
            "0000C66C386CC600", "0000CCCCCC7C0CF8", "0000FC983064FC00", "1C3030E030301C00",
            "1818180018181800", "E030301C3030E000", "76DC000000000000",
        ]
    },
    "thin": {
        "width": 8,
        "height": 8,
        "glyphs": [
            "0000000000000000", "1038381010001000", "2424240000000000", "24247E247E242400",
            "183E403C027C1800", "0062640810264600", "3048305688887600", "1010200000000000",
            "1020404040201000", "2010080808102000", "004438FE38440000", "0010107C10100000",
            "0000000000101020", "0000007E00000000", "0000000000101000", "0002040810204000",
            "3C42464A52623C00", "1030501010107C00", "3C42020C30427E00", "3C42021C02423C00",
            "08182848FE081C00", "7E407C0202423C00", "1C20407C42423C00", "7E42040810101000",
            "3C42423C42423C00", "3C42423E02043800", "0010100000101000", "0010100000101020",
            "0810204020100800", "00007E00007E0000", "1008040204081000", "3C42020408000800",

            "3C425E525E403C00", "182442427E424200", "7C22223C22227C00", "1C22404040221C00",
            "7824222222247800", "7E22283828227E00", "7E22283828207000", "1C2240404E221E00",
            "4242427E42424200", "3810101010103800", "0E04040444443800", "6224283028246300",
            "7020202020227E00", "6355494141414100", "62524A4642424200", "1824424242241800",
            "7C22223C20207000", "3C4242424A3C0300", "7C22223C28247200", "3C42403C02423C00",
            "7F49080808081C00", "4242424242423C00", "4141414122140800", "4141414949493600",
            "4122140814224100", "4122140808081C00", "7F42040810217F00", "7840404040407800",
            "8040201008040200", "7808080808087800", "1028448200000000", "00000000000000FF",

            "1010080000000000", "00003C023E423F00", "6020202E31312E00", "00003C4240423C00",
            "0602023A46463B00", "00003C427E403C00", "0C12103810103800", "00003D42423E027C",
            "60202C3222226200", "1000301010103800", "020006020242423C", "6020242830282600",
            "3010101010103800", "0000764949494900", "00005C6242424200", "00003C4242423C00",
            "00006C32322C2070", "0000364C4C34040E", "00006C3222207000", "00003E403C027C00",
            "10107C1010120C00", "0000424242463A00", "0000414122140800", "0000414949493600",
            "0000442810284400", "00004242423E027C", "00007C0810207C00", "0C10106010100C00",
            "1010100010101000", "3008080608083000", "324C000000000000",
        ]
    },
    "pcjr": {
        "width": 8,
        "height": 8,
        "glyphs": [
            "0000000000000000", "3078783030003000", "6C6C6C0000000000", "6C6CFE6CFE6C6C00",
            "307CC0780CF83000", "00C6CC183066C600", "386C3876DCCC7600", "6060C00000000000",
            "1830606060301800", "6030181818306000", "00663CFF3C660000", "003030FC30300000",
            "0000000000303060", "000000FC00000000", "0000000000303000", "060C183060C08000",
            "7CC6CEDEF6E67C00", "307030303030FC00", "78CC0C3860CCFC00", "78CC0C380CCC7800",
            "1C3C6CCCFE0C1E00", "FCC0F80C0CCC7800", "3860C0F8CCCC7800", "FCCC0C1830303000",
            "78CCCC78CCCC7800", "78CCCC7C0C187000", "0030300000303000", "0030300000303060",
            "183060C060301800", "0000FC0000FC0000", "6030180C18306000", "78CC0C1830003000",

            "7CC6DEDEDEC07800", "3078CCCCFCCCCC00", "FC66667C6666FC00", "3C66C0C0C0663C00",
            "F86C6666666CF800", "FE6268786862FE00", "FE6268786860F000", "3C66C0C0CE663E00",
            "CCCCCCFCCCCCCC00", "7830303030307800", "1E0C0C0CCCCC7800", "E6666C786C66E600",
            "F06060606266FE00", "C6EEFEFED6C6C600", "C6E6F6DECEC6C600", "386CC6C6C66C3800",
            "FC66667C6060F000", "78CCCCCCDC781C00", "FC66667C6C66E600", "78CCE0701CCC7800",
            "FCB4303030307800", "CCCCCCCCCCCCFC00", "CCCCCCCCCC783000", "C6C6C6D6FEEEC600",
            "C6C66C38386CC600", "CCCCCC7830307800", "FEC68C183266FE00", "7860606060607800",
            "C06030180C060200", "7818181818187800", "10386CC600000000", "00000000000000FF",

            "3030180000000000", "0000780C7CCC7600", "E060607C6666DC00", "000078CCC0CC7800",
            "1C0C0C7CCCCC7600", "000078CCFCC07800", "386C60F06060F000", "000076CCCC7C0CF8",
            "E0606C766666E600", "3000703030307800", "0C000C0C0CCCCC78", "E060666C786CE600",
            "7030303030307800", "0000CCFEFED6C600", "0000F8CCCCCCCC00", "000078CCCCCC7800",
            "0000DC66667C60F0", "000076CCCC7C0C1E", "0000DC766660F000", "00007CC0780CF800",
            "10307C3030341800", "0000CCCCCCCC7600", "0000CCCCCC783000", "0000C6D6FEFE6C00",
            "0000C66C386CC600", "0000CCCCCC7C0CF8", "0000FC983064FC00", "1C3030E030301C00",
            "1818180018181800", "E030301C3030E000", "76DC000000000000",
        ]
    },
    "tandy": {
        "width": 8,
        "height": 8,
        "glyphs": [
            "0000000000000000", "183C3C1818001800", "3636360000000000", "36367F367F363600",
            "183E603C067C1800", "0063660C18336300", "1C361C3B6E663B00", "1818300000000000",
            "0C18303030180C00", "30180C0C0C183000", "00663CFF3C660000", "0018187E18180000",
            "0000000000181830", "0000007E00000000", "0000000000181800", "03060C183060C000",
            "3E63676F7B733E00", "1838181818187E00", "3C66061C30667E00", "3C66061C06663C00",
            "0E1E36667F060F00", "7E607C0606663C00", "1C30607C66663C00", "7E66060C18181800",
            "3C66663C66663C00", "3C66663E060C3800", "0018180000181800", "0018180000181830",
            "060C1830180C0600", "00007E007E000000", "30180C060C183000", "3C66060C18001800",

            "3E636F6F6F603C00", "1C3663637F636300", "7E33333E33337E00", "1E33606060331E00",
            "7C36333333367C00", "7F31343C34317F00", "7F31343C34307800", "1E33606067331F00",
            "6666667E66666600", "3C18181818183C00", "0F06060666663C00", "7333363C36337300",
            "7830303031337F00", "63777F7F6B636300", "63737B6F67636300", "3E63636363633E00",
            "7E33333E30307800", "3E636363636F3E03", "7E33333E36337300", "3C6670380E663C00",
            "7E5A181818183C00", "6363636363633E00", "66666666663C1800", "6363636B7F776300",
            "6363361C1C366300", "6666663C18183C00", "7F63460C19337F00", "3C30303030303C00",
            "6030180C06030100", "3C0C0C0C0C0C3C00", "081C360000000000", "00000000000000FF",

            "18180C0000000000", "00003C063E663B00", "70303E3333336E00", "00003C6660663C00",
            "0E063E6666663B00", "00003C667E603C00", "1C36307830307800", "00003B66663E067C",
            "7030363B33337300", "1800381818183C00", "06000E060666663C", "703033363C367300",
            "3818181818183C00", "0000E67F7F6B6300", "00006E3333333300", "00003C6666663C00",
            "00006E33333E3078", "00003B66663E060F", "00006E3B33307800", "00003E603C067C00",
            "10307C3030361C00", "0000666666663B00", "00006666663C1800", "0000636B7F7F3600",
            "000063361C366300", "00006666663E067C", "00007E4C18327E00", "0E18187018180E00",
            "1818180018181800", "7018180E18187000", "3B6E000000000000",
        ]
    },
    "tandy2": {
        "width": 8,
        "height": 8,
        "glyphs": [
            "0000000000000000", "183C3C1818001800", "6666240000000000", "6C6CFE6CFE6C6C00",
            "183E603C067C1800", "00C6CC183066C600", "386C3876DCCC7600", "1818300000000000",
            "0C18303030180C00", "30180C0C0C183000", "00663CFF3C660000", "0018187E18180000",
            "0000000000181830", "0000007E00000000", "0000000000181800", "060C183060C08000",
            "386CC6D6C66C3800", "1838181818187E00", "7CC6061C3066FE00", "7CC6063C06C67C00",
            "1C3C6CCCFE0C1E00", "FEC0C0FC06C67C00", "3860C0FCC6C67C00", "FEC60C1830303000",
            "7CC6C67CC6C67C00", "7CC6C67E060C7800", "0018180000181800", "0018180000181830",
            "060C1830180C0600", "00007E00007E0000", "30180C060C183000", "7CC60C1818001800",

            "7CC6DEDEDEC07800", "386CC6FEC6C6C600", "FC66667C6666FC00", "3C66C0C0C0663C00",
            "F86C6666666CF800", "FE6268786862FE00", "FE6268786860F000", "3C66C0C0CE663A00",
            "C6C6C6FEC6C6C600", "3C18181818183C00", "1E0C0C0CCCCC7800", "E6666C786C66E600",
            "F06060606266FE00", "C6EEFEFED6C6C600", "C6E6F6DECEC6C600", "7CC6C6C6C6C67C00",
            "FC66667C6060F000", "7CC6C6C6C6CE7C0E", "FC6666786C66E600", "3C6630180C663C00",
            "7E5A181818183C00", "C6C6C6C6C6C67C00", "C6C6C6C6C66C3800", "C6C6C6D6D6FE6C00",
            "C6C66C386CC6C600", "6666663C18183C00", "FEC68C183266FE00", "3C30303030303C00",
            "C06030180C060200", "3C0C0C0C0C0C3C00", "10386CC600000000", "00000000000000FF",

            "30180C0000000000", "0000780C7CCC7600", "E0607C666666DC00", "00007CC6C0C67C00",
            "1C0C7CCCCCCC7600", "00007CC6FEC07C00", "3C6660F86060F000", "000076CCCC7C0CF8",
            "E0606C766666E600", "1800381818183C00", "060006060666663C", "E060666C786CE600",
            "3818181818183C00", "0000ECFED6D6D600", "0000DC6666666600", "00007CC6C6C67C00",
            "0000DC66667C60F0", "000076CCCC7C0C1E", "0000DC766060F000", "00007EC07C06FC00",
            "3030FC3030361C00", "0000CCCCCCCC7600", "0000C6C6C66C3800", "0000C6D6D6FE6C00",
            "0000C66C386CC600", "0000C6C6C67E06FC", "00007E4C18327E00", "0E18187018180E00",
            "1818181818181800", "7018180E18187000", "76DC000000000000",
        ]
    },
    // https://damieng.com/blog/2011/02/20/typography-in-8-bits-system-fonts
    "spectrum": {
        "width": 8,
        "height": 8,
        "glyphs": [
            "0000000000000000",
            "0010101010001000", "0024240000000000", "00247e24247e2400", "00083e283e0a3e08",
            "0062640810264600", "001028102a443a00", "0008100000000000", "0004080808080400",
            "0020101010102000", "000014083e081400", "000008083e080800", "0000000000080810",
            "000000003e000000", "0000000000181800", "0000020408102000", "003c464a52623c00",
            "0018280808083e00", "003c42023c407e00", "003c420c02423c00", "00081828487e0800",
            "007e407c02423c00", "003c407c42423c00", "007e020408101000", "003c423c42423c00",
            "003c42423e023c00", "0000001000001000", "0000100000101020", "0000040810080400",
            "0000003e003e0000", "0000100804081000", "003c420408000800", "003c4a565e403c00",

            "003c42427e424200", "007c427c42427c00", "003c424040423c00", "0078444242447800",
            "007e407c40407e00", "007e407c40404000", "003c42404e423c00", "0042427e42424200",
            "003e080808083e00", "0002020242423c00", "0044487048444200", "0040404040407e00",
            "0042665a42424200", "004262524a464200", "003c424242423c00", "007c42427c404000",
            "003c4242524a3c00", "007c42427c444200", "003c403c02423c00", "00fe101010101000",
            "0042424242423c00", "0042424242241800", "00424242425a2400", "0042241818244200",
            "0082442810101000", "007e040810207e00", "000e080808080e00", "0000402010080400",
            "0070101010107000", "0010385410101000", "00000000000000ff", "001c227820207e00",

            "000038043c443c00", "0020203c22223c00", "00001c2020201c00", "0004043c44443c00",
            "0000384478403c00", "000c101810101000", "00003c44443c0438", "0040407844444400",
            "0010003010103800", "0004000404042418", "0020283030282400", "0010101010100c00",
            "0000685454545400", "0000784444444400", "0000384444443800", "0000784444784040",
            "00003c44443c0406", "00001c2020202000", "0000384038047800", "0010381010100c00",
            "0000444444443800", "0000444428281000", "0000445454542800", "0000442810284400",
            "00004444443c0438", "00007c0810207c00", "000e083008080e00", "0008080808080800",
            "0070100c10107000", "0014280000000000", "3c4299a1a199423c",
        ]
    },
    // https://damieng.com/blog/2011/02/20/typography-in-8-bits-system-fonts
    "c64": {
        "width": 8,
        "height": 8,
        "glyphs": [
            "0000000000000000",
            "1818181800001800", "6666660000000000", "6666ff66ff666600", "183e603c067c1800",
            "62660c1830664600", "3c663c3867663f00", "060c180000000000", "0c18303030180c00",
            "30180c0c0c183000", "00663cff3c660000", "0018187e18180000", "0000000000181830",
            "0000007e00000000", "0000000000181800", "0003060c18306000", "3c666e7666663c00",
            "1818381818187e00", "3c66060c30607e00", "3c66061c06663c00", "060e1e667f060600",
            "7e607c0606663c00", "3c66607c66663c00", "7e660c1818181800", "3c66663c66663c00",
            "3c66663e06663c00", "0000180000180000", "0000180000181830", "0e18306030180e00",
            "00007e007e000000", "70180c060c187000", "3c66060c18001800", "3c666e6e60623c00",

            "183c667e66666600", "7c66667c66667c00", "3c66606060663c00", "786c6666666c7800",
            "7e60607860607e00", "7e60607860606000", "3c66606e66663c00", "6666667e66666600",
            "3c18181818183c00", "1e0c0c0c0c6c3800", "666c7870786c6600", "6060606060607e00",
            "63777f6b63636300", "66767e7e6e666600", "3c66666666663c00", "7c66667c60606000",
            "3c666666663c0e00", "7c66667c786c6600", "3c66603c06663c00", "7e18181818181800",
            "6666666666663c00", "66666666663c1800", "6363636b7f776300", "66663c183c666600",
            "6666663c18181800", "7e060c1830607e00", "181818ffff181818", "c0c03030c0c03030",
            "1818181818181818", "3333cccc3333cccc", "3399cc663399cc66", "0000000000000000",

            "00003c063e663e00", "0060607c66667c00", "00003c6060603c00", "0006063e66663e00",
            "00003c667e603c00", "000e183e18181800", "00003e66663e067c", "0060607c66666600",
            "0018003818183c00", "000600060606063c", "0060606c786c6600", "0038181818183c00",
            "0000667f7f6b6300", "00007c6666666600", "00003c6666663c00", "00007c66667c6060",
            "00003e66663e0606", "00007c6660606000", "00003e603c067c00", "00187e1818180e00",
            "0000666666663e00", "00006666663c1800", "0000636b7f3e3600", "0000663c183c6600",
            "00006666663e0c78", "00007e0c18307e00", "3c30303030303c00", "0c12307c3062fc00",
            "3c0c0c0c0c0c3c00", "00183c7e18181818", "0010307f7f301000", "000000ffff000000",
        ]
    },
    // https://damieng.com/blog/2011/02/20/typography-in-8-bits-system-fonts
    "msx": {
        "width": 7,
        "height": 8,
        "glyphs": [
            "0000000000000000",
            "1010101000001000", "2828280000000000", "28287c287c282800", "103c503814781000",
            "60640810204c0c00", "20502054484c3000", "0408100000000000", "0810202020100800",
            "2010080808102000", "1054381038541000", "0010107c10100000", "0000000000101020",
            "0000007c00000000", "0000000000181800", "0000040810204000", "38444c5464443800",
            "1030501010107c00", "3844040830407c00", "3844041804443800", "081828487c080800",
            "7c40700804087000", "1820407844443800", "7c44081010101000", "3844443844443800",
            "3844443c04083000", "0000100000100000", "0000100000101020", "0c18306030180c00",

            "00007c007c000000", "6030180c18306000", "3844040810001000", "3844043454543800",
            "102844447c444400", "7824243824247800", "1824404040241800", "7028242424287000",
            "7c40407840407c00", "7c40407840404000", "3844405c44443800", "4444447c44444400",
            "3810101010103800", "1c08080848483000", "4448506050484400", "4040404040407c00",
            "446c545444444400", "446464544c4c4400", "3844444444443800", "7844447840404000",
            "3844444454483400", "7844447850484400", "3844403804443800", "7c10101010101000",
            "4444444444443800", "4444444428281000", "44444454546c4400", "4444281028444400",
            "4444443810101000", "7c04081020407c00", "3820202020203800", "0000402010080400",

            "3808080808083800", "1028440000000000", "0000000000007c00", "2010080000000000",
            "000038043c443c00", "4040586444645800", "0000384440443800", "0404344c444c3400",
            "000038447c403800", "0814107c10101000", "0000344c4c340438", "4040784444444400",
            "1000301010103800", "0800180808084830", "4040485060504800", "3010101010103800",
            "0000685454545400", "0000586444444400", "0000384444443800", "0000586464584040",
            "0000344c4c340404", "0000586440404000", "00003c4078047800", "2020782020241800",
            "0000484848483400", "0000444444281000", "0000444454542800", "0000442810284400",
            "000044444c340438", "00007c0810207c00", "0c10102010100c00", "1010100010101000",
            "6010100810106000", "2054080000000000", "0000000000000000", "0000000000000000",
        ]
    },
    // https://damieng.com/blog/2011/02/20/typography-in-8-bits-system-fonts
    "bbc": {
        "width": 8,
        "height": 8,
        "glyphs": [
            "0000000000000000",
            "1818181818001800", "6c6c6c0000000000", "36367f367f363600", "0c3f683e0b7e1800",
            "60660c1830660600", "386c6c386d663b00", "0c18300000000000", "0c18303030180c00",
            "30180c0c0c183000", "00187e3c7e180000", "0018187e18180000", "0000000000181830",
            "0000007e00000000", "0000000000181800", "00060c1830600000", "3c666e7e76663c00",
            "1838181818187e00", "3c66060c18307e00", "3c66061c06663c00", "0c1c3c6c7e0c0c00",
            "7e607c0606663c00", "1c30607c66663c00", "7e060c1830303000", "3c66663c66663c00",
            "3c66663e060c3800", "0000181800181800", "0000181800181830", "0c18306030180c00",
            "00007e007e000000", "30180c060c183000", "3c660c1818001800", "3c666e6a6e603c00",

            "3c66667e66666600", "7c66667c66667c00", "3c66606060663c00", "786c6666666c7800",
            "7e60607c60607e00", "7e60607c60606000", "3c66606e66663c00", "6666667e66666600",
            "7e18181818187e00", "3e0c0c0c0c6c3800", "666c7870786c6600", "6060606060607e00",
            "63777f6b6b636300", "6666767e6e666600", "3c66666666663c00", "7c66667c60606000",
            "3c6666666a6c3600", "7c66667c6c666600", "3c66603c06663c00", "7e18181818181800",
            "6666666666663c00", "66666666663c1800", "63636b6b7f776300", "66663c183c666600",
            "6666663c18181800", "7e060c1830607e00", "7c60606060607c00", "006030180c060000",
            "3e06060606063e00", "183c664200000000", "00000000000000ff", "1c36307c30307e00",

            "00003c063e663e00", "60607c6666667c00", "00003c6660663c00", "06063e6666663e00",
            "00003c667e603c00", "1c30307c30303000", "00003e66663e063c", "60607c6666666600",
            "1800381818183c00", "1800381818181870", "6060666c786c6600", "3818181818183c00",
            "0000367f6b6b6300", "00007c6666666600", "00003c6666663c00", "00007c66667c6060",
            "00003e66663e0607", "00006c7660606000", "00003e603c067c00", "30307c3030301c00",
            "0000666666663e00", "00006666663c1800", "0000636b6b7f3600", "0000663c183c6600",
            "00006666663e063c", "00007e0c18307e00", "0c18187018180c00", "1818180018181800",
            "3018180e18183000", "0000000000000000", "0000000000000000", "0000000000000000"
        ]
    },
    "ega": {
        "width": 8,
        "height": 14,
        "glyphs": [
            "00000000000000000000000000", "0000183C3C3C18180018180000", "00666666240000000000000000", "00006C6CFE6C6C6CFE6C6C0000",
            "18187CC6C2C07C0686C67C1818", "00000000C2C60C183066C60000", "0000386C6C3876DCCCCC760000", "00303030600000000000000000",
            "00000C183030303030180C0000", "000030180C0C0C0C0C18300000", "00000000663CFF3C6600000000", "0000000018187E181800000000",
            "00000000000000001818183000", "000000000000FE000000000000", "00000000000000000018180000", "000002060C183060C080000000",
            "00007CC6CEDEF6E6C6C67C0000", "000018387818181818187E0000", "00007CC6060C183060C6FE0000", "00007CC606063C0606C67C0000",
            "00000C1C3C6CCCFE0C0C1E0000", "0000FEC0C0C0FC0606C67C0000", "00003860C0C0FCC6C6C67C0000", "0000FEC6060C18303030300000",
            "00007CC6C6C67CC6C6C67C0000", "00007CC6C6C67E06060C780000", "00000018180000001818000000", "00000018180000001818300000",
            "0000060C18306030180C060000", "00000000007E00007E00000000", "00006030180C060C1830600000", "00007CC6C60C18180018180000",

            "00007CC6C6DEDEDEDCC07C0000", "000010386CC6C6FEC6C6C60000", "0000FC6666667C666666FC0000", "00003C66C2C0C0C0C2663C0000",
            "0000F86C66666666666CF80000", "0000FE66626878686266FE0000", "0000FE66626878686060F00000", "00003C66C2C0C0DEC6663A0000",
            "0000C6C6C6C6FEC6C6C6C60000", "00003C181818181818183C0000", "00001E0C0C0C0C0CCCCC780000", "0000E6666C6C786C6C66E60000",
            "0000F060606060606266FE0000", "0000C6EEFEFED6C6C6C6C60000", "0000C6E6F6FEDECEC6C6C60000", "0000386CC6C6C6C6C66C380000",
            "0000FC6666667C606060F00000", "00007CC6C6C6C6D6DE7C0C0E00", "0000FC6666667C6C6666E60000", "00007CC6C660380CC6C67C0000",
            "00007E7E5A18181818183C0000", "0000C6C6C6C6C6C6C6C67C0000", "0000C6C6C6C6C6C66C38100000", "0000C6C6C6C6D6D6FE7C6C0000",
            "0000C6C66C3838386CC6C60000", "0000666666663C1818183C0000", "0000FEC68C183060C2C6FE0000", "00003C303030303030303C0000",
            "000080C0E070381C0E06020000", "00003C0C0C0C0C0C0C0C3C0000", "10386CC6000000000000000000", "000000000000000000000000FF",

            "30301800000000000000000000", "0000000000780C7CCCCC760000", "0000E06060786C6666667C0000", "00000000007CC6C0C0C67C0000",
            "00001C0C0C3C6CCCCCCC760000", "00000000007CC6FEC0C67C0000", "0000386C6460F0606060F00000", "000000000076CCCCCC7C0CCC78",
            "0000E060606C76666666E60000", "000018180038181818183C0000", "00000606000E0606060666663C", "0000E06060666C786C66E60000",
            "000038181818181818183C0000", "0000000000ECFED6D6D6C60000", "0000000000DC66666666660000", "00000000007CC6C6C6C67C0000",
            "0000000000DC6666667C6060F0", "000000000076CCCCCC7C0C0C1E", "0000000000DC76666060F00000", "00000000007CC6701CC67C0000",
            "0000103030FC303030361C0000", "0000000000CCCCCCCCCC760000", "0000000000666666663C180000", "0000000000C6C6D6D6FE6C0000",
            "0000000000C66C38386CC60000", "0000000000C6C6C6C67E060CF8", "0000000000FECC183066FE0000", "00000E181818701818180E0000",
            "00001818181800181818180000", "0000701818180E181818700000", "000076DC000000000000000000",
        ]
    },
    "mda": {
        "width": 9,
        "height": 14,
        "glyphs": [
            "0000000000000000000000000000", "0000183C3C3C1818001818000000", "0063636322000000000000000000", "000036367F3636367F3636000000",
            "0C0C3E6361603E0343633E0C0C00", "000000006163060C183363000000", "00001C36361C3B6E66663B000000", "0030303060000000000000000000",
            "00000C183030303030180C000000", "0000180C06060606060C18000000", "00000000663CFF3C660000000000", "000000181818FF18181800000000",
            "0000000000000000181818300000", "000000000000FF00000000000000", "0000000000000000001818000000", "00000103060C1830604000000000",
            "00003E63676F7B7363633E000000", "00000C1C3C0C0C0C0C0C3F000000", "00003E6303060C1830637F000000", "00003E6303031E0303633E000000",
            "0000060E1E36667F06060F000000", "00007F6060607E0303633E000000", "00001C3060607E6363633E000000", "00007F6303060C18181818000000",
            "00003E6363633E6363633E000000", "00003E6363633F0303063C000000", "0000001818000000181800000000", "0000001818000000181830000000",
            "0000060C18306030180C06000000", "00000000007E00007E0000000000", "00006030180C060C183060000000", "00003E6363060C0C000C0C000000",

            "00003E63636F6F6F6E603E000000", "0000081C3663637F636363000000", "00007E3333333E3333337E000000", "00001E336160606061331E000000",
            "00007C363333333333367C000000", "00007F3331343C3431337F000000", "00007F3331343C34303078000000", "00001E336160606F63331D000000",
            "0000636363637F63636363000000", "00003C181818181818183C000000", "00000F060606060666663C000000", "0000733336363C36363373000000",
            "000078303030303031337F000000", "0000C3E7FFDBC3C3C3C3C3000000", "000063737B7F6F67636363000000", "00001C366363636363361C000000",
            "00007E3333333E30303078000000", "00003E636363636B6F3E06070000", "00007E3333333E36333373000000", "00003E6363301C0663633E000000",
            "0000FFDB9918181818183C000000", "000063636363636363633E000000", "0000C3C3C3C3C3C3663C18000000", "0000C3C3C3C3DBDBFF6666000000",
            "0000C3C3663C183C66C3C3000000", "0000C3C3C3663C1818183C000000", "0000FFC3860C183061C3FF000000", "00003C303030303030303C000000",
            "0000406070381C0E070301000000", "00003C0C0C0C0C0C0C0C3C000000", "081C366300000000000000000000", "000000000000000000000000FF00",

            "18180C0000000000000000000000", "00000000003C063E66663B000000", "00007030303C363333336E000000", "00000000003E636060633E000000",
            "00000E06061E366666663B000000", "00000000003E637F60633E000000", "00001C3632307C30303078000000", "00000000003B6666663E06663C00",
            "0000703030363B33333373000000", "00000C0C001C0C0C0C0C1E000000", "00000606000E0606060666663C00", "000070303033363C363373000000",
            "00001C0C0C0C0C0C0C0C1E000000", "0000000000E6FFDBDBDBDB000000", "00000000006E3333333333000000", "00000000003E636363633E000000",
            "00000000006E3333333E30307800", "00000000003B6666663E06060F00", "00000000006E3B33303078000000", "00000000003E63380E633E000000",
            "00000818187E1818181B0E000000", "000000000066666666663B000000", "0000000000C3C3C3663C18000000", "0000000000C3C3DBDBFF66000000",
            "000000000063361C1C3663000000", "0000000000636363633F03063C00", "00000000007F660C18337F000000", "00000E181818701818180E000000",
            "0000181818180018181818000000", "0000701818180E18181870000000", "00003B6E00000000000000000000",
        ]
    },
    "vga": {
        "width": 9,
        "height": 16,
        "glyphs": [
            "00000000000000000000000000000000", "0000183C3C3C18181800181800000000", "00666666240000000000000000000000", "0000006C6CFE6C6C6CFE6C6C00000000",
            "18187CC6C2C07C060686C67C18180000", "00000000C2C60C183060C68600000000", "0000386C6C3876DCCCCCCC7600000000", "00303030600000000000000000000000",
            "00000C18303030303030180C00000000", "000030180C0C0C0C0C0C183000000000", "0000000000663CFF3C66000000000000", "000000000018187E1818000000000000",
            "00000000000000000018181830000000", "00000000000000FE0000000000000000", "00000000000000000000181800000000", "0000000002060C183060C08000000000",
            "00003C66C3C3DBDBC3C3663C00000000", "00001838781818181818187E00000000", "00007CC6060C183060C0C6FE00000000", "00007CC606063C060606C67C00000000",
            "00000C1C3C6CCCFE0C0C0C1E00000000", "0000FEC0C0C0FC060606C67C00000000", "00003860C0C0FCC6C6C6C67C00000000", "0000FEC606060C183030303000000000",
            "00007CC6C6C67CC6C6C6C67C00000000", "00007CC6C6C67E0606060C7800000000", "00000000181800000018180000000000", "00000000181800000018183000000000",
            "000000060C18306030180C0600000000", "00000000007E00007E00000000000000", "0000006030180C060C18306000000000", "00007CC6C60C18181800181800000000",

            "0000007CC6C6DEDEDEDCC07C00000000", "000010386CC6C6FEC6C6C6C600000000", "0000FC6666667C66666666FC00000000", "00003C66C2C0C0C0C0C2663C00000000",
            "0000F86C6666666666666CF800000000", "0000FE6662687868606266FE00000000", "0000FE6662687868606060F000000000", "00003C66C2C0C0DEC6C6663A00000000",
            "0000C6C6C6C6FEC6C6C6C6C600000000", "00003C18181818181818183C00000000", "00001E0C0C0C0C0CCCCCCC7800000000", "0000E666666C78786C6666E600000000",
            "0000F06060606060606266FE00000000", "0000C3E7FFFFDBC3C3C3C3C300000000", "0000C6E6F6FEDECEC6C6C6C600000000", "00007CC6C6C6C6C6C6C6C67C00000000",
            "0000FC6666667C60606060F000000000", "00007CC6C6C6C6C6C6D6DE7C0C0E0000", "0000FC6666667C6C666666E600000000", "00007CC6C660380C06C6C67C00000000",
            "0000FFDB991818181818183C00000000", "0000C6C6C6C6C6C6C6C6C67C00000000", "0000C3C3C3C3C3C3C3663C1800000000", "0000C3C3C3C3C3DBDBFF666600000000",
            "0000C3C3663C18183C66C3C300000000", "0000C3C3C3663C181818183C00000000", "0000FFC3860C183060C1C3FF00000000", "00003C30303030303030303C00000000",
            "00000080C0E070381C0E060200000000", "00003C0C0C0C0C0C0C0C0C3C00000000", "10386CC6000000000000000000000000", "00000000000000000000000000FF0000",

            "30301800000000000000000000000000", "0000000000780C7CCCCCCC7600000000", "0000E06060786C666666667C00000000", "00000000007CC6C0C0C0C67C00000000",
            "00001C0C0C3C6CCCCCCCCC7600000000", "00000000007CC6FEC0C0C67C00000000", "0000386C6460F060606060F000000000", "000000000076CCCCCCCCCC7C0CCC7800",
            "0000E060606C7666666666E600000000", "00001818003818181818183C00000000", "00000606000E06060606060666663C00", "0000E06060666C78786C66E600000000",
            "00003818181818181818183C00000000", "0000000000E6FFDBDBDBDBDB00000000", "0000000000DC66666666666600000000", "00000000007CC6C6C6C6C67C00000000",
            "0000000000DC66666666667C6060F000", "000000000076CCCCCCCCCC7C0C0C1E00", "0000000000DC7666606060F000000000", "00000000007CC660380CC67C00000000",
            "0000103030FC30303030361C00000000", "0000000000CCCCCCCCCCCC7600000000", "0000000000C3C3C3C3663C1800000000", "0000000000C3C3C3DBDBFF6600000000",
            "0000000000C3663C183C66C300000000", "0000000000C6C6C6C6C6C67E060CF800", "0000000000FECC183060C6FE00000000", "00000E18181870181818180E00000000",
            "00001818181800181818181800000000", "0000701818180E181818187000000000", "000076DC000000000000000000000000",
        ]
    },
    "olivetti": {
        "width": 8,
        "height": 16,
        "glyphs": [
            "00000000000000000000000000000000", "0000183C3C3C18180018180000000000", "00666666240000000000000000000000", "000036367F3636367F36360000000000",
            "08083E6360603E0303633E0808000000", "0000006163060C183063430000000000", "00001C36361C3B6E66663B0000000000", "00303030600000000000000000000000",
            "00000C183030303030180C0000000000", "000030180C0C0C0C0C18300000000000", "00000000663C7E3C6600000000000000", "0000000018187E181800000000000000",
            "00000000000000001818183000000000", "0000000000007E000000000000000000", "00000000000000000018180000000000", "00000103060C18306040000000000000",
            "00003E63676F7B7363633E0000000000", "00000C1C3C0C0C0C0C0C3F0000000000", "00003E6303060C1830637F0000000000", "00003E6303031E0303633E0000000000",
            "0000060E1E36667F06060F0000000000", "00007E6060607E0303633E0000000000", "00001C3060607E6363633E0000000000", "00007F6303060C181818180000000000",
            "00003E6363633E6363633E0000000000", "00003E6363633F0303061C0000000000", "00000018180000001818000000000000", "00000018180000001818300000000000",
            "0000060C18306030180C060000000000", "000000007E0000007E00000000000000", "00006030180C060C1830600000000000", "00003E6363060C0C000C0C0000000000",

            "00003E63636F6F6F6E603E0000000000", "0000081C3663637F6363630000000000", "00007E3333333E3333337E0000000000", "00001E336060606060331E0000000000",
            "00007C363333333333367C0000000000", "00007F3330343C3430337F0000000000", "00007F3330343C343030780000000000", "00001E336060606F63331D0000000000",
            "0000636363637F636363630000000000", "00003C181818181818183C0000000000", "00000F060606060666663C0000000000", "0000733336363C363633730000000000",
            "000078303030303030337F0000000000", "000063777F6B63636363630000000000", "000063737B7F6F676363630000000000", "00001C366363636363361C0000000000",
            "00007E3333333E303030780000000000", "00001C36636363636B3E1C0603000000", "00007E3333333E363333730000000000", "00003E6363301C0663633E0000000000",
            "00007E5A1818181818183C0000000000", "000063636363636363633E0000000000", "0000636363636363361C080000000000", "000063636363636B6B7F360000000000",
            "0000636363361C366363630000000000", "000066666666663C18183C0000000000", "00007F63060C183060637F0000000000", "00003C303030303030303C0000000000",
            "0000406030180C060301000000000000", "00003C0C0C0C0C0C0C0C3C0000000000", "081C3663000000000000000000000000", "00000000000000000000000000007F00",

            "18180C00000000000000000000000000", "00000000003C063E66663B0000000000", "00007030303E333333336E0000000000", "00000000003E636060633E0000000000",
            "00000E06063E666666663B0000000000", "00000000003E637F60633E0000000000", "00001E33307C30303030780000000000", "00000000003B666666663E06663C0000",
            "00007030303E33333333730000000000", "00000C0C001C0C0C0C0C1E0000000000", "00000C0C001C0C0C0C0C0C0CCC780000", "000070303033363C3633730000000000",
            "00001C0C0C0C0C0C0C0C1E0000000000", "0000000000667F6B6B6B6B0000000000", "00000000006E33333333330000000000", "00000000003E636363633E0000000000",
            "00000000006E333333333E3030780000", "00000000003B666666663E06060F0000", "00000000006E33303030780000000000", "00000000003E63380E633E0000000000",
            "00000008187E1818181B0E0000000000", "000000000066666666663B0000000000", "0000000000636363361C080000000000", "000000000063636B6B7F360000000000",
            "000000000063361C1C36630000000000", "000000000063666666663E06663C0000", "00000000007F660C18337F0000000000", "00000E181818701818180E0000000000",
            "00001818181800181818180000000000", "0000701818180E181818700000000000", "00003B6E000000000000000000000000",
        ]
    },
    // http://www.seasip.info/VintagePC/wy700.html
    "wyse_serif": {
        "width": 16,
        "height": 16,
        "glyphs": [
            '0000000000000000000000000000000000000000000000000000000000000000', '0000000003c007e00ff00ff00ff007e003c003c0000003c003c0000000000000',
            '00003c3c3c3c1c380c3000000000000000000000000000000000000000000000', '0000000000001c381c387ffe1c381c381c381c387ffe1c381c38000000000000',
            '03c003c007e01e783c3c3c001e0007e00078003c3c3c1e7807e003c003c00000', '00000000000000003c3c3c7800f001e003c007800f001e3c3c3c000000000000',
            '0000000007c01ef03c781ef007c00f9e3ffc78f878783cfc0f9e000000000000', '00000f000f000f001e0000000000000000000000000000000000000000000000',
            '0000000001e003c007800f000f000f000f000f00078003c001e0000000000000', '0000000001e000f00078003c003c003c003c003c007800f001e0000000000000',
            '000000000000000000003c3c0ff07ffe0ff03c3c000000000000000000000000', '000000000000000003c003c003c07ffe03c003c003c000000000000000000000',
            '000000000000000000000000000000000000000003c003c00380070000000000', '00000000000000000000000000007ffe00000000000000000000000000000000',
            '0000000000000000000000000000000000000000000003c003c0000000000000', '000000000000003c007800f001e003c007800f001e003c000000000000000000',

            '0000000007e01e783c3c3c7c3cfc3dbc3f3c3e3c3c3c1e7807e0000000000000', '0000000003c00fc03fc003c003c003c003c003c003c003c03ffc000000000000',
            '000000000fe03c78003c003c007800f003c00f001e003c3c3ffc000000000000', '000000000ff03c3c001e001e003c03f0003c001e001e3c3c0ff0000000000000',
            '0000000001f003f007f00ff01ef03cf03ffc00f000f000f003fc000000000000', '000000003ffe3c003c003c003ff0003c001e001e001e3c3c0ff0000000000000',
            '0000000007f01e003c003c003c003ff03c3c3c1e3c1e1e3c07f0000000000000', '000000003ffc3c3c003c007800f001e003c003c003c003c003c0000000000000',
            '0000000007f01e3c3c1e3c1e1e3c07f01e3c3c1e3c1e1e3c07f0000000000000', '0000000007f01e3c3c1e3c1e1e1e07fe001e001e001e003c0ff0000000000000',
            '000000000000000003c003c0000000000000000003c003c00000000000000000', '000000000000000003c003c0000000000000000003c003c00780000000000000',
            '0000000001e003c007800f001e003c001e000f00078003c001e0000000000000', '0000000000000000000000003ffc000000003ffc000000000000000000000000',
            '00000000078003c001e000f00078003c007800f001e003c00780000000000000', '0000000007e01e783c3c007800f001e003c003c0000003c003c0000000000000',

            '000000000ffc3c1e781e79fe7b8e7b8e7b8e79fc78003c000ffc000000000000', '0000000003c007e00ff01e783c3c3c3c3ffc3c3c3c3c3c3c3c3c000000000000',
            '000000007ff01e3c1e1e1e1e1e3c1ff01e3c1e1e1e1e1e3c7ff0000000000000', '0000000007f01e3c3c1e3c003c003c003c003c003c1e1e3c07f0000000000000',
            '000000007ff01e3c1e1e1e1e1e1e1e1e1e1e1e1e1e1e1e3c7ff0000000000000', '000000007ffe1e0e1e061e001e601fe01e601e001e061e0e7ffe000000000000',
            '000000007ffe1e0e1e061e001e601fe01e601e001e001e007f80000000000000', '0000000007f01e3c3c1e3c003c003c003c7e3c1e3c1e1e3e07f6000000000000',
            '000000003c1e3c1e3c1e3c1e3c1e3ffe3c1e3c1e3c1e3c1e3c1e000000000000', '000000000ff003c003c003c003c003c003c003c003c003c00ff0000000000000',
            '0000000003fe00780078007800780078007800783c781ff007c0000000000000', '000000007e3c1e781ef01fe01fc01fc01fe01ef01e781e3c7e1e000000000000',
            '000000007f801e001e001e001e001e001e001e001e061e0e7ffe000000000000', '00000000781e7c3e7e7e7ffe7bde799e781e781e781e781e781e000000000000',
            '000000003c1e3c1e3e1e3f1e3f9e3dde3cfe3c7e3c3e3c1e3c1e000000000000', '0000000007f01e3c3c1e3c1e3c1e3c1e3c1e3c1e3c1e1e3c07f0000000000000',

            '000000007ff01e3c1e1e1e1e1e3c1ff01e001e001e001e007f80000000000000', '0000000007f01e3c3c1e3c1e3c1e3c1e3c1e3dde3cfe1e7c07f8001c00000000',
            '000000007ff01e3c1e1e1e1e1e3c1ff01fe01ef01e781e3c7e1e000000000000', '000000000ff03c3c781e3c000f0003c000f0003c781e3c3c0ff0000000000000',
            '000000007ffe73ce63c603c003c003c003c003c003c003c00ff0000000000000', '000000003c1e3c1e3c1e3c1e3c1e3c1e3c1e3c1e3c1e1e3c07f0000000000000',
            '000000003c3c3c3c3c3c3c3c3c3c3c3c3c3c1e780ff007e003c0000000000000', '00000000781e781e781e781e781e781e799e7bde7ffe3e7c1c38000000000000',
            '000000003c3c3c3c1e780ff007e003c007e00ff01e783c3c3c3c000000000000', '000000003c3c3c3c3c3c3c3c1e780ff007e003c003c003c00ff0000000000000',
            '000000003ffc383c307800f001e003c007800f001e0c3c1c3ffc000000000000', '000000000ff00f000f000f000f000f000f000f000f000f000ff0000000000000',
            '0000000000003c001e000f00078003c001e000f00078003c0000000000000000', '000000000ff000f000f000f000f000f000f000f000f000f00ff0000000000000',
            '03c007e00ff01e783c3c00000000000000000000000000000000000000000000', '000000000000000000000000000000000000000000000000000000007fff0000',

            '03c003c001e00000000000000000000000000000000000000000000000000000', '0000000000000000000000000fe000780ff83c783c783c780f9e000000000000',
            '000000003f000f000f000f000ff00f3c0f1e0f1e0f1e0f1e3cf8000000000000', '0000000000000000000000000ff83c1e3c003c003c003c1e0ff8000000000000',
            '0000000001f800780078007807f81e783c783c783c783c780f9e000000000000', '0000000000000000000000000ff83c1e3c1e3ffe3c003c1e0ff8000000000000',
            '0000000003f00f3c0f0c0f000f003ff00f000f000f000f003fc0000000000000', '0000000000000000000000000f9e3c783c783c783c780ff800783c780fe00000',
            '000000003f000f000f000f000f780f9e0f1e0f1e0f1e0f1e3f1e000000000000', '00000000000000f000f0000003f000f000f000f000f000f003fc000000000000',
            '000000000000003c003c000000fc003c003c003c003c003c3c3c1e7807e00000', '000000003f000f000f000f000f1e0f3c0f780ff00f780f3c3f1e000000000000',
            '0000000003f000f000f000f000f000f000f000f000f000f003fc000000000000', '0000000000000000000000007e7c7ffe7bde7bde7bde7bde7bde000000000000',
            '0000000000000000000000003cf80f3c0f1e0f1e0f1e0f1e0f1e000000000000', '00000000000000000000000007f01e3c3c1e3c1e3c1e1e3c07f0000000000000',

            '0000000000000000000000003cf00f3c0f1e0f1e0f3c0ff00f000f003fc00000', '000000000000000000000000079e1e783c783c781e7807f80078007800fe0000',
            '0000000000000000000000003cf80f9e0f000f000f000f003fc0000000000000', '0000000000000000000000000ff83c1e3c000ff8001e3c1e0ff8000000000000',
            '0000000001800380078007807ff80780078007800780079e01f8000000000000', '0000000000000000000000003c783c783c783c783c783c780f9e000000000000',
            '000000000000000000000000781e781e781e781e1e7807e00180000000000000', '000000000000000000000000781e781e781e799e7bde3ffc1e78000000000000',
            '0000000000000000000000003c3c0e7007e003c007e00e703c3c000000000000', '0000000000000000000000003c1e3c1e3c1e3c1e1e1e07fe001e003c0ff00000',
            '0000000000000000000000003ffc3c3c00f003c00f003c3c3ffc000000000000', '0000000000fc01e003c003c003c03f8003c003c003c001e000fc000000000000',
            '0000000003c003c003c003c003c0000003c003c003c003c003c0000000000000', '000000003f00078003c003c003c001fc03c003c003c007803f00000000000000',
            '000000000f9e3cf8000000000000000000000000000000000000000000000000', '000000000000000000c003f00f3c3c0f3c0f3fff000000000000000000000000'
        ]
    },
    // http://www.seasip.info/VintagePC/wy700.html
    "wyse_sans": {
        "width": 16,
        "height": 16,
        "glyphs": [
            '0000000000000000000000000000000000000000000000000000000000000000', '0000000001c001c001c001c001c001c001c001c0000001c001c0000000000000',
            '00001c381c381c381c3800000000000000000000000000000000000000000000', '0000000000001c381c387ffe1c381c381c381c387ffe1c381c38000000000000',
            '000001800ff0399c718e718039800ff0019c018e718e399c0ff0018000000000', '00000000000000001e1c1e38007000e001c0038007000e3c1c3c000000000000',
            '0000000007c01c7038381c7007c00fce38fc7078707838fc0fce000000000000', '000000e001c00380070000000000000000000000000000000000000000000000',
            '0000000000e001c0038007000700070007000700038001c000e0000000000000', '000000000700038001c000e000e000e000e000e001c003800700000000000000',
            '000000000000000000000e3803e03ffe03e00e38000000000000000000000000', '000000000000000001c001c001c03ffe01c001c001c000000000000000000000',
            '0000000000000000000000000000000000000000000003c003c0038007000000', '00000000000000000000000000003ffe00000000000000000000000000000000',
            '0000000000000000000000000000000000000000000003c003c0000000000000', '000000000000001c0038007000e001c0038007000e001c000000000000000000',

            '0000000007e01c38383c387c38dc399c3b1c3e1c3c1c1c3807e0000000000000', '0000000001c003c00fc001c001c001c001c001c001c001c001c0000000000000',
            '000000000ff0381c000e000e001c007001c007001c0038003ffe000000000000', '000000000ff0381c000e000e001c01f0001c000e000e381c0ff0000000000000',
            '0000000001f003f007700e701c7038703ffc0070007000700070000000000000', '000000003ffe3800380038003ff0001c000e000e000e381c0ff0000000000000',
            '0000000007f01c003800380038003ff0381c380e380e1c1c07f0000000000000', '000000003ff800380038007000e001c003800380038003800380000000000000',
            '0000000007f01c1c380e380e1c1c07f01c1c380e380e1c1c07f0000000000000', '0000000007f01c1c380e380e1c0e07fe000e000e000e001c0ff0000000000000',
            '0000000000000000038003800000000000000000038003800000000000000000', '0000000000000000038003800000000000000000038003800700000000000000',
            '0000000000e001c0038007000e001c000e000700038001c000e0000000000000', '0000000000000000000000003ffc000000003ffc000000000000000000000000',
            '000000000700038001c000e000700038007000e001c003800700000000000000', '0000000007e01c38381c0038007000e001c001c0000001c001c0000000000000',

            '000000000ff0381c700e71fe738e738e738e71fc700038000ffc000000000000', '0000000003c007e00e701c38381c381c3ffc381c381c381c381c000000000000',
            '000000003ff0381c380e380e381c3ff0381c380e380e381c3ff0000000000000', '0000000007f01c1c380e38003800380038003800380e1c1c07f0000000000000',
            '000000003ff0381c380e380e380e380e380e380e380e381c3ff0000000000000', '000000003ffc38003800380038003fe038003800380038003ffc000000000000',
            '000000003ffc38003800380038003fe038003800380038003800000000000000', '0000000007f01c1c380e380038003800383e380e380e1c1c07f0000000000000',
            '00000000380e380e380e380e380e3ffe380e380e380e380e380e000000000000', '0000000001c001c001c001c001c001c001c001c001c001c001c0000000000000',
            '00000000001c001c001c001c001c001c001c001c1c1c0e3803e0000000000000', '000000001c381c701ce01dc01f801f801dc01ce01c701c381c1c000000000000',
            '0000000038003800380038003800380038003800380038003ffc000000000000', '00000000781e7c3e7e7e77ee73ce718e700e700e700e700e700e000000000000',
            '00000000380e3c0e3e0e3f0e3b8e39ce38ee387e383e381e380e000000000000', '0000000007f01c1c380e380e380e380e380e380e380e1c1c07f0000000000000',

            '000000003ff0381c380e380e381c3ff038003800380038003800000000000000', '0000000007f01c1c380e380e380e380e380e380e38ee1c7c07f8001c00000000',
            '000000003ff0381c380e380e381c3ff038e038703838381c380e000000000000', '000000000ff0381c700e700038000ff0001c000e700e381c0ff0000000000000',
            '000000003ffe01c001c001c001c001c001c001c001c001c001c0000000000000', '00000000380e380e380e380e380e380e380e380e380e1c1c07f0000000000000',
            '00000000381c381c381c381c381c381c381c1c380e7007e003c0000000000000', '00000000700e700e700e700e700e700e718e73ce77ee3e7c1c38000000000000',
            '00000000381c381c1c380e7007e003c007e00e701c38381c381c000000000000', '00000000380e1c1c0e38077003e001c001c001c001c001c001c0000000000000',
            '000000003ffe001c0038007000e001c0038007000e001c003ffe000000000000', '0000000007f007000700070007000700070007000700070007f0000000000000',
            '0000000000001c000e000700038001c000e000700038001c0000000000000000', '0000000007f000700070007000700070007000700070007007f0000000000000',
            '03c007e00e701c38381c00000000000000000000000000000000000000000000', '00000000000000000000000000000000000000000000000000000000ffff0000',

            '00000700038001c000e000000000000000000000000000000000000000000000', '0000000000000000000000000ff8000e0ffe380e380e380e0ffe000000000000',
            '0000000038003800380038003ff0381c380e380e380e380e3ff8000000000000', '0000000000000000000000000ff8380e380038003800380e0ff8000000000000',
            '00000000000e000e000e000e07fe1c0e380e380e380e380e0ffe000000000000', '0000000000000000000000000ff8380e380e3ffe380038000ffc000000000000',
            '0000000000f803800380038003800ff003800380038003800380000000000000', '0000000000000000000000000ff8380e380e380e380e0ffe000e000e1ff80000',
            '0000000038003800380038003bf83c0e380e380e380e380e380e000000000000', '00000000000001c001c0000001c001c001c001c001c001c001c0000000000000',
            '000000000000007000700000007000700070007000700070007000e00f800000', '000000000e000e000e000e000e380e700ee00fc00ee00e700e38000000000000',
            '0000000001c001c001c001c001c001c001c001c001c001c001c0000000000000', '0000000000000000000000003e7839ce39ce39ce39ce39ce39ce000000000000',
            '0000000000000000000000003fe03838381c381c381c381c381c000000000000', '00000000000000000000000007f01c1c380e380e380e1c1c07f0000000000000',

            '0000000000000000000000003ff0381c380e380e381c3ff03800380038000000', '00000000000000000000000007fe1c0e380e380e1c0e07fe000e000e000e0000',
            '0000000000000000000000003ff0381c38003800380038003800000000000000', '0000000000000000000000000ffc380038000ff8000e000e1ff8000000000000',
            '0000000001c001c001c001c01ffc01c001c001c001c001c001c0000000000000', '000000000000000000000000381c381c381c381c381c381c0ffc000000000000',
            '000000000000000000000000700e381c1c380e7007e003c00180000000000000', '000000000000000000000000380e380e380e39ce3bee1f7c0e38000000000000',
            '0000000000000000000000001c380e7007e003c007e00e701c38000000000000', '000000000000000000000000380e1c1c0e38077003e001c0038007000e000000',
            '0000000000000000000000003ffe001c007001c007001c003ffe000000000000', '0000000000f801c00380038003801e0003800380038001c000f8000000000000',
            '0000000001c001c001c001c001c0000001c001c001c001c001c0000000000000', '000000001f00038001c001c001c0007801c001c001c003801f00000000000000',
            '00000000079e3cf0000000000000000000000000000000000000000000000000', '000000000000000001c007701c1c700770077fff000000000000000000000000'
        ]
    },

}


function buildFont(name) {
    var glyphs = {};
    var font = FONTS[name].glyphs;
    var width = FONTS[name].width;
    function toBinary(x)
    {
        var bin = parseInt(x, 16).toString(2);
        return "0".repeat(width - bin.length) + bin;
    }
    for (var i=0; i < font.length; ++i) {
        // split into two-hexit substrings, convert each to binary
        var glyph;
        // we can handle 8-bit wide and 16-bit wide
        if (width <= 8) glyph = font[i].match(/.{1,2}/g).map(toBinary);
        else glyph = font[i].match(/.{1,4}/g).map(toBinary);
        // convert to list of booleans
        glyphs[String.fromCharCode(32+i)] = glyph.map( function(y) { return y.split("").map(function(x) { return x === "1" }); });
    }
    return glyphs;
}

///////////////////////////////////////////////////////////////////////////////
// tokens

function SeparatorToken(bracket_char)
{
    this.token_type = bracket_char;
    this.payload = bracket_char;
}

function LiteralToken(value)
{
    this.token_type = "literal";
    this.operation = function opLiteral(x) { return x; };
    this.payload = value;
}

function NameToken(value)
{
    this.token_type = "name";
    this.payload = value;
}

function newFunctionToken(keyword, operation) {
    return (function() {
        return (new function FunctionToken() {
            this.token_type = "function";
            this.payload = keyword;
            this.operation = operation;
        }() );
    } );
}
function newStatementToken(keyword, operation) {
    return (function() {
        return (new function StatementToken() {
            this.token_type = "statement";
            this.payload = keyword;
            this.operation = operation;
        }() );
    } );
}
function newOperatorToken(keyword, narity, precedence, operation) {
    return (function() {
        return (new function OperatorToken() {
            this.token_type = "operator";
            this.payload = keyword;
            this.narity = narity;
            this.precedence = precedence;
            this.operation = operation;
        }() );
    } );
}

var SYMBOLS = {
    "^": newOperatorToken("^", 2, 12, Math.pow),
    "*": newOperatorToken("*", 2, 11, opMultiply),
    "/": newOperatorToken("/", 2, 11, opDivide),
    "+": newOperatorToken("+", null, 8, opPlus),
    "-": newOperatorToken("-", null, 8, opMinus),
    "=": newOperatorToken("=", 2, 7, opEqual),
    ">": newOperatorToken(">", 2, 7, opGreaterThan),
    ">=": newOperatorToken(">=", 2, 7, opGreaterThanOrEqual),
    "<": newOperatorToken("<", 2, 7, opLessThan),
    "<=": newOperatorToken("<=", 2, 7, opLessThanOrEqual),
    "<>": newOperatorToken("<>", 2, 7, opNotEqual),
}

var KEYWORDS = {
    "ABS": newFunctionToken("ABS", Math.abs),
    "AND": newOperatorToken("AND", 2, 5, opAnd),
    "ASC": newFunctionToken("ASC", fnAsc),
    "ATN": newFunctionToken("ATN", Math.atan),
    "CHR$": newFunctionToken("CHR$", String.fromCharCode),
    "COS": newFunctionToken("COS", Math.cos),
    "DIM": newStatementToken("DIM", stDim),
    "EXP": newFunctionToken("EXP", Math.exp),
    "INPUT": newStatementToken("INPUT", stInput),
    "INT": newFunctionToken("INT", Math.trunc),
    "LEFT$": newFunctionToken("LEFT$", fnLeft),
    "LEN": newFunctionToken("LEN", fnLen),
    "LET": newStatementToken("LET", stLet),
    "LOG": newFunctionToken("LOG", Math.log),
    "MID$": newFunctionToken("MID$", fnMid),
    "NOT": newOperatorToken("NOT", 1, 6, opNot),
    "OR": newOperatorToken("OR", 2, 4, opOr),
    "PRINT": newStatementToken("PRINT", stPrint),
    "READ": newStatementToken("READ", stRead),
    "RESTORE": newStatementToken("RESTORE", stRestore),
    "RIGHT$": newFunctionToken("RIGHT$", fnRight),
    "SGN": newFunctionToken("SGN", Math.sign),
    "SIN": newFunctionToken("SIN", Math.sin),
    "SQR": newFunctionToken("SQR", Math.sqrt),
    "TAB": newFunctionToken("TAB", fnTab),
    "TAN": newFunctionToken("TAN", Math.tan),
    "VAL": newFunctionToken("VAL", fnVal),
    // declarations with no runtime effect
    "DATA": newStatementToken("DATA", null),
    "DEF": newStatementToken("DEF", null),
    "REM": newStatementToken("REM", null),
    // Flow statements are handled by a special node, not a statement operation
    "FOR": newStatementToken("FOR", null),
    "GOSUB": newStatementToken("GOSUB", null),
    "GOTO": newStatementToken("GOTO", null),
    "IF": newStatementToken("IF", null),
    "ON": newStatementToken("ON", null),
    "NEXT": newStatementToken("NEXT", null),
    "RETURN": newStatementToken("RETURN", null),
    "END": newStatementToken("END", null),
    "STOP": newStatementToken("STOP", null),
    "RUN":  newStatementToken("RUN", null),
    // non-statement keywords
    "THEN": newStatementToken("THEN", null),
    "STEP": newStatementToken("STEP", null),
    "TO": newStatementToken("TO", null),
    "FN": newFunctionToken("FN", fnFn),
}

// additional reserved words: AS, AT, GR, LN, PI, ST, TI, TI$


///////////////////////////////////////////////////////////////////////////////
// lexer


function Lexer(expr_string)
// convert expression string to list of tokens
{
    var pos = 0;

    function isNumberChar(char)
    {
        return (char >= "0" && char <= "9");
    }

    function isAlphaChar(char)
    {
        return (char >= "a" && char <= "z") || (char >= "A" && char <= "Z");
    }

    function readString()
    // read a double-quoted string literal
    {
        var start_pos = pos;
        // skip start and closing quotes
        for (++pos; (pos < expr_string.length && expr_string[pos] !== '"'  && expr_string[pos] !== "\n"); ++pos);
        var output = expr_string.slice(start_pos+1, pos);
        if (expr_string[pos] === "\n") {
            console.log("String literal terminated by end-of-line");
            --pos;
        }
        return output;
    }

    function readComment()
    // read a comment until end of line
    {
        // skip single space after REM, if any
        var start_pos = ++pos;
        for (; (pos < expr_string.length && expr_string[pos] !== "\n"); ++pos);
        --pos;
        if (expr_string[start_pos] === " ") ++start_pos;
        return expr_string.slice(start_pos, pos+1);
    }


    function readName()
    // read a name (variable or keyword)
    {
        var start_pos = pos;
        for (; pos < expr_string.length-1; ++pos){
            // the name can end in at most one $
            if (expr_string[pos+1] === "$") {
                ++pos;
                break;
            }
            if (expr_string.slice(start_pos, pos+1).toUpperCase() in KEYWORDS) {
                // names can not start with a keyword
                break;
            }
            if (!isAlphaChar(expr_string[pos+1]) && !isNumberChar(expr_string[pos+1])) break;
        }
        return expr_string.slice(start_pos, pos+1).toUpperCase();
    }

    function readInteger()
    // read an unsigned integer literal (i.e. a string of numbers)
    {
        var start_pos = pos;
        for (; pos < expr_string.length-1; ++pos){
            if (!isNumberChar(expr_string[pos+1])) break;
        }
        return expr_string.slice(start_pos, pos+1);
    }

    this.readValue = function()
    {
        // for VAL(), we should also accept a - here
        var sign = "";
        var mantissa = "0";
        var decimal = "0";
        var exponent = "0";
        if (expr_string[pos] === "-") {
            sign = "-";
            ++pos;
        }
        var char = expr_string[pos];
        if (isNumberChar(char)) {
            mantissa = readInteger();
        }
        else {
            --pos;
        }
        if (pos+1 < expr_string.length && expr_string[pos+1] === ".") {
            ++pos;
            if (pos+1 < expr_string.length && isNumberChar(expr_string[pos+1])) {
                ++pos;
                decimal = readInteger();
            }
        }
        if (pos+1 < expr_string.length && (expr_string[pos+1] === "E" || expr_string[pos+1] === "e")) {
            ++pos;
            if (pos+1 < expr_string.length &&
                    (isNumberChar(expr_string[pos+1]) || expr_string[pos+1] === "-" || expr_string[pos+1] === "+")) {
                if (expr_string[pos+1] === "-" || expr_string[pos+1] === "+") {
                    exponent = expr_string[pos+1];
                    ++pos;
                }
                ++pos;
                exponent += readInteger();
            }
        }
        return parseFloat(sign + mantissa + "." + decimal + "e" + exponent);
    }

    this.tokenise = function()
    {
        // start with a line break to get the parser to expect a line number
        var expr_list = [new SeparatorToken("\n")];
        for (pos=0; pos < expr_string.length; ++pos) {
            var char = expr_string[pos];
            // deal with line breaks, CR, LF and CR LF all work
            if (char === "\r") {
                if (pos+1 < expr_string.length && expr_string[pos+1] === "\n") {
                    ++pos;
                }
                char = "\n";
            }
            if (char in SYMBOLS) {
                var operator = char;
                // two-symbol operators all start with lt or gt
                if (char == "<" || char == ">") {
                    if (pos+1 < expr_string.length) {
                        var char2 = expr_string[pos+1];
                        if (char2 == "<" || char2 == ">" || char2 == "=") {
                            operator += char2;
                            ++pos;
                        }
                    }
                }
                expr_list.push(SYMBOLS[operator]());
            }
            else if (char === "(" || char === ")" ||
                        char === "," || char === ";" ||
                        char === ":" || char === "\n") {
                expr_list.push(new SeparatorToken(char));
            }
            // double quotes, starts a string
            else if (char === '"') {
                expr_list.push(new LiteralToken(readString()));
            }
            // numeric character, starts a number literal
            else if (isNumberChar(char) || char === ".") {
                expr_list.push(new LiteralToken(this.readValue()));
            }
            else if (isAlphaChar(char)) {
                var name = readName();
                if (name in KEYWORDS) {
                    // call function that calls new on a constructor
                    expr_list.push(KEYWORDS[name]());
                    if (name === "REM") {
                        expr_list.push(new LiteralToken(readComment()));
                    }
                }
                else {
                    expr_list.push(new NameToken(name));
                }
            }
            else if (char !== " ") {
                // we can't throw here in case there"s subroutines<1000 attached
                expr_list.push(new SeparatorToken(char));
                console.log("Unexpected symbol `"+ char + "` during lexing");
            }
        }
        return expr_list;
    }
}



///////////////////////////////////////////////////////////////////////////////
// AST


function Literal(value)
// literal node holds a string or number value
// only for use in expressions, so no step() or next needed
{
    this.value = value;
    this.evaluate = function() { return this.value; }
}

function Node(func, node_args, program)
// used as expression or statement node
{
    this.func = func;
    this.args = node_args;
    this.next = null;
    this.program = program;

    // traverse AST to evaluate this node and all its subnodes
    this.evaluate = function()
    {
        // evaluate all arguments
        var args = this.args.map(function (x) { return x.evaluate(); });
        // call the function with the array supplied as arguments
        return this.func.apply(this.program, args);
    };

    this.step = function()
    {
        this.evaluate();
        return this.next;
    }
}

// flow nodes

function Label(label)
// label node: no-op but can be a jump target
{
    this.label = label;
    this.next = null;
    this.step = function() {
        return this.next;
    }
}

function End()
{
    this.next = null;
    this.step = function() { return null; }
}

function Run(program)
{
    this.next = null;

    this.step = function() {
        subClear(program);
        return program.tree;
    }
}

function Conditional(condition)
{
    this.condition = condition;
    this.branch = null;
    this.next = null;

    this.step = function()
    {
        if (this.condition.evaluate()) return this.branch;
        return this.next;
    }
}

function Switch(condition, branches)
// ON node
{
    this.condition = condition;
    this.branches = branches;
    this.next = null;

    this.step = function()
    {
        var condition = this.condition.evaluate();
        if (typeof condition !== "number" && typeof condition !== "boolean") {
            throw new BasicError("Type mismatch", "expected numerical expression, got `"+ condition+"`");
        }
        if (condition > 0 && condition <= this.branches.length) {
            return this.branches[condition-1];
        }
        else {
            return this.next;
        }
    }
}

function Jump(target, program, is_sub)
{
    this.target = target;
    this.next = null;

    this.step = function()
    {
        if (!(target in program.line_numbers)) {
            throw new BasicError("Undefined line number in `GOTO " + target + "`");
        }
        if (is_sub) program.sub_stack.push(this.next);
        return program.line_numbers[target];
    }
}

function Return(program)
// RETURN node
{
    this.step = function()
    {
        return program.sub_stack.pop();
    }
}

function Wait(wait_condition)
// execute node after waiting for condition to become true
// unlike Conditional, the condition is evaluated repeatedy until true
// e.g. wait for a keypress

{
    this.trigger = wait_condition;
    this.next = null;
    this.delay = IDLE_DELAY;

    this.step = function()
    {
        if (this.trigger()) return this.next;
        return this;
    }
}

function For(loop_name, start, stop, incr, program)
{
    this.next = null;

    this.step = function()
    {
        program.variables.assign(start.evaluate(), loop_name, []);
        var for_record = {
            "name": loop_name,
            "next": this.next,
            "stop": stop.evaluate(),
            "incr": incr.evaluate(),
        }
        program.loop_stack.unshift(for_record);
        return this.next;
    }
}

function Next(loop_name, program)
// iteration node
{
    this.next = null;
    this.delay = busy_delay;

    this.step = function()
    {
        var for_record = program.loop_stack[0];
        while (loop_name !== for_record.name) {
            console.log("Popping from loop stack unexpectedly, did we jump out of a loop?");
            program.loop_stack.shift();
            for_record = program.loop_stack[0];
        }
        var loop_var = program.variables.retrieve(loop_name, []);
        var incr = for_record.incr;
        var stop = for_record.stop;
        // iterate if ((i+step)*step) < (stop*step) to deal with negative steps
        if (incr*(loop_var+incr) <= incr*stop) {
            program.variables.assign(loop_var + incr, loop_name, []);
            return for_record.next;
        }
        program.loop_stack.shift();
        return this.next;
    }
}


//////////////////////////////////////////////////////////////////////
// program object

function Program(basicode)
{
    // parsing output
    this.title = "";
    this.description = "";
    this.data = new Data();
    this.fns = new Functions();
    this.line_numbers = {};
    this.tree = new Label();

    // build the tree
    var tokenised_code = new Lexer(basicode).tokenise();
    var parser = new Parser(tokenised_code, this);
    parser.parse(this.tree);

    // runtime state
    this.variables = new Variables();
    this.sub_stack = [];
    this.loop_stack = [];
    this.current_line = 999;

    this.clear = function()
    {
        this.variables.clear();
        this.data.restore();
        this.sub_stack = [];
        this.current_line = 999;
    }

    this.attach = function(machine)
    // attach program to machine emulator
    {
        this.output = machine.display;
        this.input = machine.keyboard;
        this.printer = machine.printer;
        this.speaker = machine.speaker;
        this.timer = machine.timer;
        this.storage = machine.storage;
    }
}


//////////////////////////////////////////////////////////////////////
// parser


function Parser(expr_list, program)
{
    // current line being parsed
    var current_line = 999;

    // for loop variables
    var for_stack = [];

    function drain(precedence, stack, units)
    // pop operator stack until matching precedence is encountered
    {
        while ((stack.length > 0)) {

            if (precedence > stack[stack.length-1].precedence) {
                break;
            }
            var token = stack.pop();
            var args = units.slice(units.length - token.narity);
            // we need to pop without slicing the units
            // to affect the mutable argument
            for (var i=0; i < args.length; ++i) {
                units.pop();
            }
            units.push(new Node(token.operation, args, program));
        }
        return units;
    };

    this.parseExpression = function(parameter, fn_name)
    // parse expression from a list of tokens to an AST
    // variation of Dijkstra"s shunting-yard algorithm, following PC-BASIC
    {
        var stack = [];
        var units = [];
        var token = null;
        var exit_loop = false;
        while (expr_list.length > 0) {
            var last = token;
            token = expr_list.shift();
            if (token.token_type === "operator") {
                // only a unary operator after another operator or at the start
                var narity = 2;
                if (last === null || last.token_type === "operator") {
                    // narity 1: prefix, 2: binary infix
                    // narity null is for - which can be prefix or infix
                    narity = 1;
                }
                if (token.narity !== null && token.narity !== narity) {
                    throw new BasicError("Syntax error", "unexpected operator type", current_line);
                }
                if (narity === 2) {
                    // drain stack until precedence is matched
                    drain(token.precedence, stack, units);
                }
                // (copy and?) override the narity of - before pushing
                token.narity = narity;
                stack.push(token)
            }
            else if (last === null || last.token_type === "operator") {
                switch (token.token_type) {
                    case "function":
                        if (token.payload === "FN") var name = expr_list.shift();
                        var args = this.parseArguments(parameter, fn_name);
                        if (token.payload === "FN") args.unshift(new Literal(name.payload));
                        units.push(new Node(token.operation, args, program));
                        break;
                    case "(":
                        // recursive call, gets a Node object containing AST
                        units.push(this.parseExpression(parameter, fn_name));
                        var bracket = expr_list.shift(token);
                        if (bracket.token_type !== ")") {
                            throw new BasicError("Syntax error", "expected `)`, got `" + bracket.payload + "`", current_line);
                        }
                        break;
                    case "literal":
                        units.push(new Literal(token.payload));
                        break;
                    case "name":
                        // user function parameter, must not be array element
                        if (parameter !== undefined && token.payload === parameter) {
                            units.push(new Node(opRetrieveParameter, [new Literal(fn_name)], program));
                        }
                        else {
                            var indices = this.parseArguments(parameter, fn_name);
                            units.push(new Node(opRetrieve, [new Literal(token.payload)].concat(indices), program));
                        }
                        break;
                    default:
                        expr_list.unshift(token);
                        exit_loop = true;
                        break;
                }
            }
            else {
                expr_list.unshift(token);
                break;
            }
            if (exit_loop) {
                break;
            }
        }
        drain(0, stack, units);
        if (units.length) return units[0];
        return null;
    };

    this.parseArguments = function(parameter, fn_name)
    {
        var args = [];
        if (expr_list.length > 0 && expr_list[0].token_type === "(") {
            expr_list.shift();
            while (expr_list.length > 0) {
                args.push(this.parseExpression(parameter, fn_name));
                var token = expr_list.shift();
                if (token.token_type === ")") break;
                if (token.token_type !== ",") {
                    throw  new BasicError("Syntax error", "expected `,`, got `"+token.payload+"`", current_line);
                }
            }
            if (token.token_type !== ")") {
                throw new BasicError("Syntax error", "missing `)`", current_line);
            }
        }
        return args;
    }

    this.parseLineNumber = function(last)
    {
        if (!expr_list.length) return null;
        var token = expr_list.shift();
        while (expr_list.length) {
            // ignore empty lines
            while (token.token_type === "\n") token = expr_list.shift();
            // we do need a line number at the start
            if (token.token_type != "literal") {
                throw new BasicError("Syntax error", "expected line number, got `"+token.payload+"`", current_line);
            }
            var line_number = token.payload;
            // ignore lines < 1000
            if (line_number >= 1000) break;
            while (token.token_type !== "\n") token = expr_list.shift();
        }
        if (line_number <= current_line) {
            throw new BasicError("Syntax error", "expected line number > `" + current_line+"`, got `"+ line_number + "`", current_line);
        }
        current_line = line_number;
        var label = new Label(line_number);
        program.line_numbers[line_number] = label;
        last.next = label;
        return label;
    }

    this.parse = function(last, end_token)
    {
        while (expr_list.length) {
            // parse separator
            if (expr_list[0].token_type !== "literal" && expr_list[0].payload === end_token) break;
            var sep = expr_list.shift();
            if (sep.token_type === "\n") {
                // parseLineNumber deals with multiple LFs
                last.next = this.parseLineNumber(last);
                last = last.next;
            }
            else if (sep.token_type !== ":") {
                throw new BasicError("Syntax error", "expected `:`, got `" + sep.payload + "`", current_line);
            }
            if (!expr_list.length) break;
            if (expr_list[0].token_type !== "literal" && expr_list[0].payload === end_token) break;
            // handle empty statement
            if (expr_list[0].token_type === ":" || expr_list[0].token_type === "\n") continue;
            // parse statements
            var token = expr_list.shift();
            // optional LET
            if (token.token_type === "name") {
                expr_list.unshift(token);
                token = KEYWORDS["LET"]();
            }
            // parse arguments in statement-specific way
            // statement parsers must take care of maintaining the linked list
            last = PARSERS[token.payload].call(this, token, last)
        }
        return last;
    }

    ///////////////////////////////////////////////////////////////////////////
    // statement syntax

    this.parseLet = function(token, last)
    // parse LET statement
    {
        var name = expr_list.shift();
        if (name.token_type != "name") {
            throw new BasicError("Syntax error", "expected variable name, got `" + name.payload + "`", current_line);
        }
        var indices = this.parseArguments();
        var equals = expr_list.shift().payload;
        if (equals !== "=") throw new BasicError("Syntax error", "expected `=`, got `"+equals+"`", current_line);
        var value = this.parseExpression();
        // statement must have access to interpreter state, so program is first argument
        last.next = new Node(token.operation, [value, new Literal(name.payload)].concat(indices), program);
        return last.next;
    }

    this.parsePrint = function(token, last_node)
    // parse PRINT statement
    {
        var last = null;
        while (expr_list.length > 0) {
            var expr = this.parseExpression();
            if (expr !== null) {
                last_node.next = new Node(stPrint, [expr], program);
                last_node = last_node.next;
                last = expr;
            }
            else if (expr_list[0].token_type !== ";") break;
            if (!expr_list.length) break;
            if (expr_list[0].token_type === ":" || expr_list[0].token_type === "\n") break;
            last = ";";
            if (expr_list[0].token_type === ";") expr_list.shift();
        }
        if (last !== ";") {
            last_node.next = new Node(stPrint, [new Literal("\n")], program);
            last_node = last_node.next;
        }
        return last_node;
    }

    this.parseData = function(token, last)
    // parse DATA statement
    {
        var values = []
        var neg = false;
        while (expr_list.length > 0) {
            var value = expr_list.shift();
            // only literals allowed in DATA
            // we"re not allowing empty DATA statements or repeated commas
            if (value === null || (value.token_type !== "literal" && (neg || (value.token_type !== "operator" || value.payload !== "-")))) {
                throw new BasicError("Syntax error", "expected string or number literal, got `"+value.payload+"`", current_line);
            }
            if (value.token_type === "operator" && value.payload === "-") {
                neg = true;
                continue;
            }
            values.push(neg?-value.payload:value.payload);
            neg = false;
            // parse separator (,)
            if (!expr_list.length) break;
            if (expr_list[0].token_type !== ",") break;
            expr_list.shift();
        }
        // data is stored immediately upon parsing, DATA is then a no-op statement
        program.data.store(values);
        return last;
    }

    this.parseRead = function(token, last)
    // parse READ or DIM statement
    {
        var pt = last;
        while (expr_list.length > 0) {
            var name = expr_list.shift();
            if (name.token_type != "name") {
                throw new BasicError("Syntax error", "expected variable name, got `" + name.payload + "`", current_line);
            }
            var indices = this.parseArguments();

            last.next = new Node(token.operation, [new Literal(name.payload)].concat(indices), program);
            last = last.next;

            if (!expr_list.length) break;
            if (expr_list[0].token_type !== ",") break;
            expr_list.shift();
        }
        return last;
    }

    this.parseRem = function(token, last)
    // parse REM
    {
        var rem = expr_list.shift();
        if (rem.token_type !== "literal") {
            throw new BasicError("Syntax error", "expected literal, got `"+rem.payload+"`", current_line);
        }
        // BASICODE standard: title in REM on line 1000
        // description and copyrights in REMS on lines 30000 onwards
        rem = rem.payload;
        var rem_trim = rem.trim();
        if (rem_trim[0] === '"') {
            rem = rem_trim.slice(1);
            if (rem[rem.length-1] === '"') rem = rem.slice(0, rem.length-1)
        }
        if (current_line === 1000) {
            program.title = rem;
        }
        else if (current_line >= 30000) {
            program.description += rem + "\n";
        }
        return last;
    }

    this.parseGoto = function(token, last)
    // parse GOTO
    {
        var line_number = expr_list.shift();
        if (line_number.token_type !== "literal" || typeof line_number.payload !== "number") {
            throw new BasicError("Syntax error", "expected line number, got `"+line_number.payload+"`", current_line);
        }
        // GOTO 20 is a BASICODE fixture, clear and jump to 1010
        if (line_number.payload === 20) {
            last.next = new Node(subClear, [], program);
            last.next.next = new Jump(1010, program, false)
            return last.next.next;
        }
        // GOTO 950 means END
        else if (line_number.payload === 950) return new End();
        else if (line_number.payload < 1000) {
            throw new BasicError("Unimplemented BASICODE", "`GOTO "+line_number.payload+"` not implemented", current_line);
        }
        // other line numbers are resolved at run time
        last.next = new Jump(line_number.payload, program, false);
        // put a short delay on jumps to avoid overloading the browser on loops
        last.next.delay = busy_delay;
        return last.next;
    }

    this.parseGosub = function(token, last)
    // parse GOSUB
    {
        var line_number = expr_list.shift();
        if (line_number.token_type !== "literal" || typeof line_number.payload !== "number") {
            throw new BasicError("Syntax error", "expected line number, got `"+line_number.payload+"`", current_line);
        }
        else if (line_number.payload in SUBS) {
            // attach BASICODE subroutine node
            return SUBS[line_number.payload](last);
        }
        else if (line_number.payload < 1000) {
            throw new BasicError("Unimplemented BASICODE", "`GOSUB "+line_number.payload+"` not implemented", current_line);
        }
        last.next = new Jump(line_number.payload, program, true);
        return last.next;
    }

    var SUBS = {
        100: function(last) {last.next = new Node(subClearScreen, [], program); return last.next; },
        110: function(last) {last.next = new Node(subSetPos, [], program); return last.next; },
        120: function(last) {last.next = new Node(subGetPos, [], program); return last.next; },
        150: function(last) {last.next = new Node(subWriteBold, [], program); return last.next; },
        200: function(last) {last.next = new Node(subReadKey, [], program); return last.next; },
        210: function(last) {
            last.next = new Wait(function waitForKey() { return program.input.keyPressed(); });
            last.next.next = new Node(subReadKey, [], program);
            return last.next.next;
        },
        220: function(last) {last.next = new Node(subReadChar, [], program); return last.next; },
        250: function(last) {last.next = new Node(subBeep, [], program); return last.next; },
        260: function(last) {last.next = new Node(subRandom, [], program); return last.next; },
        270: function(last) {last.next = new Node(subFree, [], program); return last.next; },
        280: function(last) {last.next = new Node(subToggleBreak, [], program); return last.next; },
        300: function(last) {last.next = new Node(subNumberToString, [], program); return last.next; },
        310: function(last) {last.next = new Node(subNumberFormat, [], program); return last.next; },
        330: function(last) {last.next = new Node(subToUpperCase, [], program); return last.next; },
        350: function(last) {last.next = new Node(subLinePrint, [], program); return last.next; },
        360: function(last) {last.next = new Node(subLineFeed, [], program); return last.next; },
        400: function(last) {
            last.next = new Node(subTone, [], program);
            last.next.next = new Wait(function waitForTone() { return !program.speaker.isBusy(); });
            return last.next.next;
        },
        450: function(last) {
            last.next = new Node(subSetTimer, [], program);
            last.next.next = new Wait(function waitForKeyWithTimeout() { return (program.input.keyPressed() || program.timer.elapsed()); });
            last.next.next.next = new Node(subReadKeyGetTimer, [], program);
            return last.next.next.next;
        },
        500: function(last) {last.next = new Node(subOpen, [], program); return last.next; },
        540: function(last) {last.next = new Node(subReadFile, [], program); return last.next; },
        560: function(last) {last.next = new Node(subWriteFile, [], program); return last.next; },
        580: function(last) {last.next = new Node(subClose, [], program); return last.next; },
        600: function(last) {last.next = new Node(subClearScreen, [], program); return last.next; },
        620: function(last) {last.next = new Node(subPlot, [], program); return last.next; },
        630: function(last) {last.next = new Node(subDraw, [], program); return last.next; },
        650: function(last) {last.next = new Node(subText, [], program); return last.next; },
        // GOSUB 950 (unofficial) same as GOTO 950
        950: function(last) {last.next = new End(); return last.next; },
    }

    this.parseIf = function(token, last)
    // parse IF
    {
        var condition = this.parseExpression();
        var node = new Conditional(condition);
        last.next = node;
        var then = expr_list.shift()
        if (then.token_type !== "statement" || (then.payload !== "THEN" && then.payload !== "GOTO")) {
            throw new BasicError("Syntax error", "expected `THEN`, got `"+then.payload+"`", current_line);
        }
        // supply a GOTO if jump target given after THEN
        var jump = expr_list[0]
        if (jump.token_type === "literal") {
            expr_list.unshift(KEYWORDS["GOTO"]());
        }
        node.branch = new Label("THEN");
        node.next = new Label("FI");
        expr_list.unshift(new SeparatorToken(":"));
        var end_branch = this.parse(node.branch, "\n");
        end_branch.next = node.next;
        // give back the separator so the next line parses correctly
        expr_list.unshift(new SeparatorToken("\n"));
        // merge branch back into single node
        return node.next;
    }

    this.parseOn = function(token, last)
    // parse ON jumps
    {
        var condition = this.parseExpression();
        var jump = expr_list.shift();
        if (jump.token_type !== "statement" || (jump.payload !== "GOTO" && jump.payload !== "GOSUB")) {
            throw new BasicError("Syntax error", "expected `GOTO` or `GOSUB`, got `"+jump.payload+"`", current_line);
        }
        var is_sub = false;
        // target for RETURN and switch fallthrough
        var label = new Label("NO");
        var nodes = [];
        while (expr_list.length) {
            // create jump node of the right kind, and attach to a dummy object
            var node = PARSERS[jump.payload].call(this, jump, {})
            node.next = label;
            nodes.push(node);
            var sep = expr_list.shift();
            if (sep.token_type !== ",") {
                expr_list.unshift(sep);
                break;
            }
        }
        last.next = new Switch(condition, nodes);
        last.next.next = label;
        return label;
    }

    this.parseFor = function(token, last)
    // parse FOR
    {
        var loop_variable = expr_list.shift();
        if (loop_variable.token_type !== "name" || loop_variable.payload.slice(-1) === "$") {
            throw new BasicError("Syntax error", "expected numerical variable name, got `"+loop_variable.payload+"`", current_line);
        }
        loop_variable = loop_variable.payload;
        var equals = expr_list.shift();
        if (equals.token_type !== "operator" || equals.payload !== "=") {
            throw new BasicError("Syntax error", "expected `=`, got `"+equals.payload+"`", current_line);
        }
        var start = this.parseExpression();
        var to = expr_list.shift();
        if (to.token_type !== "statement" || to.payload !== "TO") {
            throw new BasicError("Syntax error", "expected `TO`, got `"+to.payload+"`", current_line);
        }
        var stop = this.parseExpression();
        var step = expr_list.shift();
        if (step.token_type !== "statement" || step.payload !== "STEP") {
            expr_list.unshift(step);
            step = new Literal(1);
        }
        else {
            step = this.parseExpression();
        }
        // loop init
        last.next = new For(loop_variable, start, stop, step, program);
        last = last.next;
        // keep track of for loops while parsing
        for_stack.unshift(loop_variable);
        // parse body of FOR loop until NEXT is encountered
        last = this.parse(last, "NEXT");
        // parse NEXT
        var next = this.parseNext(expr_list.shift(), last);
        // pop the varible off the FOR stack
        for_stack.shift();
        return next;
    }

    this.parseNext = function(token, last)
    // regular NEXT is handled by FOR parser
    // if we encounter it unexpectedly, this is where we get
    {
        if (token === undefined || token === null || token.payload !== "NEXT") {
            throw new BasicError("Block error", "`FOR` without `NEXT`", current_line);
        }
        // only one variable allowed
        var next_variable = expr_list.shift();
        // accept missing variable name (formally not allowed)
        if (next_variable.token_type !== "name") {
            expr_list.unshift(next_variable);
        }
        else if (for_stack[0] !== next_variable.payload) {
            throw new BasicError("Block error", "expected `NEXT `"+loop_variable+"`, got `NEXT " + next_variable.payload + "`", current_line);
        }
        // create the iteration node
        last.next = new Next(for_stack[0], program);
        // replace NEXT J,I with NEXT J: NEXT I
        if (expr_list[0].token_type === ",") {
            expr_list.shift();
            expr_list.unshift(KEYWORDS["NEXT"]());
            expr_list.unshift(new SeparatorToken(":"));
        }
        return last.next;
    },

    this.parseInput = function(token, last)
    // parse INPUT
    {
        var prompt = " ?";
        // allow a prompt string literal
        if ((expr_list[0].token_type === "literal") && (typeof expr_list[0].payload === "string")) {
            prompt = expr_list.shift().payload;
            var semicolon = expr_list.shift();
            if (semicolon.token_type !== ";") {
                throw new BasicError("Syntax error", "expected `;`, got `"+semicolon.payload+"`", current_line);
            }
        }
        // prompt
        last.next = new Node(stPrint, [new Literal("? ")], program);
        last = last.next;
        do {
            var name = expr_list.shift();
            if (name.token_type !== "name") {
                throw new BasicError("Syntax error", "expected variable name, got `" + name.payload + "`", current_line);
            }
            var indices = this.parseArguments();
            // wait for ENTER keypress before engaging
            last.next = new Wait(function() { return program.input.interact(program.output); });
            // do not retrieve the variable, just get its name
            last.next.next = new Node(stInput, [new Literal(name.payload)].concat(indices), program);
            last = last.next.next;
            var comma = null;
            if (expr_list[0].token_type === ",") comma = expr_list.shift();
        } while (comma);
        return last;
    }

    this.parseDefFn = function(token, last)
    // parse DEF FN statement
    {
        var fn = expr_list.shift();
        if (fn.token_type !== "function" || fn.payload !== "FN") {
            throw new BasicError("Syntax error", "expected `FN`, got `"+fn.payload+"`", current_line);
        }
        var name = expr_list.shift();
        if (name.token_type !== "name") {
            throw new BasicError("Syntax error", "expected function name, got `" + name.payload + "`", current_line);
        }
        var token = expr_list.shift();
        if (token.token_type !== "(") {
            throw new BasicError("Syntax error", "expected `(`, got `"+token.payload+"`", current_line);
        }
        var arg = expr_list.shift();
        if (name.token_type !== "name") {
            throw new BasicError("Syntax error", "expected parameter name, got `" + arg.payload + "`", current_line);
        }
        var token = expr_list.shift();
        if (token.token_type !== ")") {
            throw new BasicError("Syntax error", "expected `)`, got `"+token.payload+"`", current_line);
        }
        var equals = expr_list.shift().payload;
        if (equals !== "=") throw new BasicError("Syntax error", "expected `=`, got `"+equals+"`", current_line);
        var expr = this.parseExpression(arg.payload, name.payload);
        program.fns.store(name.payload, arg, expr);
        return last;
    }

    this.parseRestore = function(token, last)
    // parse RESTORE
    {
        last.next = new Node(token.operation, [], program);
        return last.next;
    }

    this.parseReturn = function(token, last)
    // parse RETURN
    {
        last.next = new Return(program);
        return last.next;
    }

    this.parseEnd = function(token, last)
    // parse END
    {
        last.next = new End();
        return last.next;
    }

    this.parseRun = function(token, last)
    // parse RUN
    {
        last.next = new Run();
        return last.next;
    }

    var PARSERS = {
        "DATA": this.parseData,
        "DIM": this.parseRead,
        "FOR": this.parseFor,
        "GOSUB": this.parseGosub,
        "GOTO": this.parseGoto,
        "IF": this.parseIf,
        "INPUT": this.parseInput,
        "LET": this.parseLet,
        "NEXT": this.parseNext,
        "ON": this.parseOn,
        "PRINT": this.parsePrint,
        "READ": this.parseRead,
        "REM": this.parseRem,
        "RESTORE": this.parseRestore,
        "RETURN": this.parseReturn,
        "END": this.parseEnd,
        "STOP": this.parseEnd,
        "RUN": this.parseRun,
        "DEF": this.parseDefFn,
    }
};


///////////////////////////////////////////////////////////////////////////////
// data store

function Data()
{
    this.vault = [];
    this.pointer = 0;

    this.read = function()
    {
        if (this.pointer < this.vault.length) return this.vault[this.pointer++];
        else throw new BasicError("Out of Data", "", null);
    };

    this.restore = function()
    {
        this.pointer = 0;
    };

    this.store = function(new_data)
    {
        this.vault = this.vault.concat(new_data);
    }

    this.clear = function()
    {
        this.vault = [];
        this.pointer = 0;
    }

}


///////////////////////////////////////////////////////////////////////////////
// types, variables, arrays

function defaultValue(name)
// default value for type given by name
{
    var default_value = 0;
    if (name.slice(-1) === "$") default_value = "";
    return default_value;
}

function matchType(name, value)
{
    var string_name = (name.slice(-1) === "$");
    var string_value = typeof value === "string";
    if (!string_value && typeof value !== "number") {
        throw new BasicError("Type mismatch" , "unknown type `"+typeof value+"`", null);
    }
    if (string_name !== string_value) {
        throw new BasicError("Type mismatch" , "", null);
    }
}

function Variables()
{
    this.clear = function()
    {
        this.arrays = {};
        this.scalars = {};
        this.dims = {};
    }

    this.allocate = function(name, indices)
    // allocate an array
    {
        // no redefinitions allowed
        if (name in this.dims || name in this.arrays) throw new BasicError("Duplicate definition", "`"+name+"()` was previously dimensioned", null);
        // BASICODE arrays may have at most two indices
        if (indices.length > 2) throw new BasicError("Subscript out of range", "too many array dimensions", null);
        // set default to empty string if string name, 0 otherwise
        var default_value = defaultValue(name);
        function allocateLevel(indices) {
            if (indices.length === 0) return default_value;
            else {
                // allocate subarray; BASICODE arrays span 0..x inclusive
                var arr = new Array(indices[0]+1);
                // feed remaining arguments to recursive call
                var argarray = indices.slice(1);
                // allocate deeper level
                for (var i=0; i < arr.length; ++i) {
                    arr[i] = allocateLevel(argarray);
                }
                return arr;
            }
        };

        // I"m assuming a name is *either* a scalar *or* an array
        // this is not true in e.g. GW-BASIC, but I think it"s true in BASICODE
        this.dims[name] = indices;
        this.arrays[name] = allocateLevel(indices);
    }

    this.checkSubscript = function(name, indices)
    {
        if (!indices.length) {
            if (!(name in this.dims) && !(name in this.scalars)) {
                this.scalars[name] = defaultValue(name);
            }
        }
        else if (!(name in this.dims)) {
            //throw new BasicError("Subscript out of range", "array was not dimensioned", null);
            // auto-dim array at 10 for each index
            var new_indices = [];
            for (var i=0; i < indices.length; ++i) {
                new_indices.push(10);
            }
            console.log("Auto-allocating array "+name+" with "+new_indices.length+" indices.");
            this.allocate(name, new_indices);
        }
        else if (indices.length !== this.dims[name].length) {
            throw new BasicError("Subscript out of range" , "expected "+this.dims[name].length+" indices, got "+indices.length, null);
        }
        else {
            for (var i=0; i < indices.length; ++i) {
                if (indices[i] < 0 || indices[i] > this.dims[name][i]) {
                    throw new BasicError("Subscript out of range", "indices "+indices+" out of bounds "+this.dims[name], null);
                }
            }
        }
    }

    this.assign = function(value, name, indices)
    // set a variable
    {
        this.checkSubscript(name, indices);

        if (indices.length === 0) {
            this.scalars[name] = value;
        }
        else if (indices.length === 1) {
            this.arrays[name][Math.round(indices[0])] = value;
        }
        else {
            this.arrays[name][Math.round(indices[0])][Math.round(indices[1])] = value;
        }
    };

    this.retrieve = function(name, indices)
    // retrieve a variable
    {
        this.checkSubscript(name, indices);

        if (indices.length === 0) {
            return this.scalars[name];
        }
        else if (indices.length === 1) {
            return this.arrays[name][Math.round(indices[0])];
        }
        else {
            return this.arrays[name][Math.round(indices[0])][Math.round(indices[1])];
        }
    };

    this.clear();
}


function Functions()
{
    this.clear = function()
    {
        this.exprs = {};
        this.args = {};
    }

    this.store = function(name, arg, expr)
    {
        this.exprs[name] = expr;
    }

    this.evaluate = function(name, arg_value)
    {
        this.args[name] = arg_value;
        return this.exprs[name].evaluate();
    }

    this.clear();
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// operations, statements, functions

// we set `this` to the current program state upon calling these

function opMultiply(x, y)
{
    return x * y;
}

function opDivide(x, y)
{
    return x / y;
}

function opPlus(x, y)
// + adds numbers or concatenates strings; unary plus leaves unchanged
{
    if (y === undefined) return x; else return x + y;
}

function opMinus(x, y)
// - can be unary negation or binary subtraction
{
    if (y === undefined) return -x; else return x - y;
}

function opEqual(x, y)
{
    return -(x === y);
}

function opGreaterThan(x, y)
{
    return -(x > y);
}

function opGreaterThanOrEqual(x, y)
{
    return -(x >= y);
}

function opLessThan(x, y)
{
    return -(x < y);
}

function opLessThanOrEqual(x, y)
{
    return -(x <= y);
}

function opNotEqual(x, y)
{
    return -(x !== y);
}

function opAnd(x, y)
{
    return (x & y);
}

function opNot(x)
{
    return (~x);
}

function opOr(x, y)
{
    return (x | y);
}

function opRetrieveParameter(fn_name)
// retrieve the user function parameter (only one allowed, no arrays)
{
    return this.fns.args[fn_name];
}

function opRetrieve(name)
//  retrieve a variable from the Variables object in program (this)
{
    var indices = [].slice.call(arguments, 1);
    var value = this.variables.retrieve(name, indices);
    return value;
}

function fnTab(x)
// set column to a given position during PRINT
// outside of PRINT, this is not allowed
// but we"re not throwing any errors
{
    this.output.setColumn(x);
    return "";
}

function fnAsc(x)
{
    return x.charCodeAt(0);
}

function fnMid(x, start, n)
{
    if (n === undefined) return x.slice(start-1);
    else return x.slice(start-1, start+n-1);
}

function fnLeft(x, n)
{
    return x.slice(0, n);
}

function fnRight(x, n)
{
    return x.slice(-n);
}

function fnLen(x, n)
{
    return x.length;
}

function fnVal(x)
{
    return new Lexer(x).readValue();
}

function fnFn(name, x)
{
    return this.fns.evaluate(name, x);
}


///////////////////////////////////////////////////////////////////////////////
// statements


function stLet(value, name)
// LET
{
    var indices = [].slice.call(arguments, 2);
    this.variables.assign(value, name, indices);
}

function stDim(name)
// DIM
{
    var indices = [].slice.call(arguments, 1);
    this.variables.allocate(name, indices);
}

function stPrint(value)
// PRINT value;
{
    if (typeof value === "string") {
        this.output.write(value);
    }
    else if (value < 0) {
        this.output.write(value.toString(10) + " ");
    }
    else {
        this.output.write(" " + value.toString(10) + " ");
    }
}

function stRestore()
// RESTORE
{
    this.data.restore();
}

function stRead(name)
// READ
{
    var indices = [].slice.call(arguments, 1);
    var value = this.data.read()
    this.variables.assign(value, name, indices);
}

function stInput(name)
// INPUT
{
    var indices = [].slice.call(arguments, 1);
    var value = this.input.readLine();
    if (name.slice(-1) !== "$") {
        // convert string to number
        // note that this will currently simply return 0 if it can't convert
        // no "Redo from start"
        value = new Lexer(value).readValue();
    }
    this.variables.assign(value, name, indices);
}


///////////////////////////////////////////////////////////////////////////////
// BASICODE subroutines and jumps

function subClear()
// GOTO 20
// clear variables
{
    this.clear();
    // basicode-3
    this.variables.assign(this.output.width - 1, "HO", []);
    this.variables.assign(this.output.height - 1, "VE", []);
    this.variables.assign(this.output.pixel_width, "HG", []);
    this.variables.assign(this.output.pixel_height, "VG", []);
    // basicode-3c
    this.variables.allocate("CC", [10]);
    this.variables.assign(7, "CC", [0]);
    this.variables.assign(0, "CC", [1]);
}

function subClearScreen()
// GOSUB 100, GOSUB 600
// 600 Switch to graphic screen and clear graphic screen
{
    subSetColour.call(this);
    this.output.clear();
}

function subSetPos()
// GOSUB 110
{
    this.output.setColumn(Math.round(this.variables.retrieve("HO", [])));
    this.output.setRow(Math.round(this.variables.retrieve("VE", [])));
}

function subGetPos()
// GOSUB 120
{
    this.variables.assign(this.output.col, "HO", []);
    this.variables.assign(this.output.row, "VE", []);
}

function subWriteBold()
// GOSUB 150
{
    subSetColour.call(this);
    var text = "  " + this.variables.retrieve("SR$", []) + "  ";
    this.output.write(" ");
    this.output.invertColour();
    this.output.write(text);
    this.output.invertColour();
    this.output.write(" ");
}

function subReadKey()
// GOSUB 200, GOSUB 210 (after wait)
{
    // GOSUB 200 should hold only capitals in IN$ and IN
    var keyval = this.input.readKey();
    var cn_keyval = 0;
    var key = "";
    if ((keyval >= 32 && keyval <= 126) || keyval === 13) {
        key = String.fromCharCode(keyval);
        keyval = key.toUpperCase().charCodeAt(0);
        cn_keyval = keyval;
        if (key >= "A" && key <= "Z") {
            cn_keyval = key.toLowerCase().charCodeAt(0);
        }
        key = key.toUpperCase();
    }
    // IN$ and IN return capitalised key codes
    // special keys generate a code in IN but not IN$
    this.variables.assign(keyval, "IN", []);
    this.variables.assign(key, "IN$", []);
    // in BC-3c, CN contains the character code of the lowercase letter
    // if an uppercase key was entered, and vice versa
    //FIXME: we sould be able to switch this off for BC-2 and BC-3 programs
    //this.variables.assign(cn_keyval, "CN", []);
}

function subSetTimer()
// GOSUB 450 (with subReadKeyGetTimer)
{
    var deciseconds = this.variables.retrieve("SD", []);
    this.timer.set(deciseconds * 100);
}

function subReadKeyGetTimer()
// GOSUB 450 (with subSetTimer)
// Wait SD*0.1 seconds or for a key stroke
// When ended: IN$ and IN contain the possible keystroke (see for special codes line 200).
// SD contains the remaining time from the moment the key was pressed or zero (if no key was pressed)
{
    subReadKey.apply(this);
    var milliseconds = this.timer.remaining();
    this.variables.assign(milliseconds/100, "SD", []);
}

function subReadChar()
// GOSUB 220
{
    var col = this.variables.retrieve("HO", []);
    var row = this.variables.retrieve("VE", []);
    var ch = this.output.getScreenChar(row, col);
    this.variables.assign(ch.charCodeAt(0), "IN", []);
}

function subBeep()
// GOSUB 250
{
    this.speaker.sound(440, 0.1, 1);
}

function subTone()
// GOSUB 400
//400 Produce a tone using SP, SD and SV
//    SP is frequency level: 0 = lowest, 60="central C", 127 = highest
//    SD is the tone duration in steps of 0.1 seconds
//    SV is the volume: 0=muted 7=medium, 15=loud
//    This subroutine keeps running during the time of SD.
{
    var freq = this.variables.retrieve("SP", []);
    var dur = this.variables.retrieve("SD", []);
    var vol = this.variables.retrieve("SV", []);
    freq = (freq===0)?0: Math.exp(freq*0.057762 + 2.10125);
    this.speaker.sound(freq, dur*0.1, vol/15.);
}

function subRandom()
// GOSUB 260
{
    this.variables.assign(Math.random(), "RV", []);
}

function subFree()
// GOSUB 270
{
    // theoretically, we should garbage-collect and return free memory
    // but let"s just return some largeish (for BASICODE) number of bytes
    this.variables.assign(65536, "FR", []);
}

function subToggleBreak()
// GOSUB 280
// 280 Disable the stop/break key (FR=1) or enable or (FR=0).
{
    this.input.suppress_break = true;
}

function subNumberToString()
// GOSUB 300
{
    var num = this.variables.retrieve("SR", []);
    this.variables.assign(num.toString(10), "SR$", []);
}

function subNumberFormat()
// GOSUB 310
// 310 Convert number SR to string with a string length of CT and with CN places after decimal point; returned in SR$,
{
    var num = this.variables.retrieve("SR", []);
    var len = this.variables.retrieve("CT", []);
    var decimals = this.variables.retrieve("CN", []);
    var str = num.toFixed(decimals);
    if (str.length > len) {
        // too long; replace with stars
        str = "*".repeat(len);
    }
    else if (str.length < len) {
        // left-pad with spaces
        str = " ".repeat(len-str.length) + str;
    }
    this.variables.assign(str, "SR$", []);
}

function subToUpperCase()
// GOSUB 330
// 330 Convert all letters in SR$ to capital letters
{
    var str = this.variables.retrieve("SR$", []);
    this.variables.assign(str.toUpperCase(), "SR$", []);
}

function subLinePrint()
// GOSUB 350
// 350 Print SR$ on the printer.
{
    var text = this.variables.retrieve("SR$", []);
    this.printer.write(text);
}

function subLineFeed()
// GOSUB 360
// 360 Carriage return and line feed on the printer.
{
    this.printer.write("\n");
}

function subOpen()
// GOSUB 500
/*
Open the file NF$ according to the code in NF:
NF = even number: input: NF= uneven number: output
    NF= 0 or 1 BASICODE cassette
    NF= 2 or 3 own system memory
    NF= 4 or 5 diskette
    NF= 6 or 7 diskette
    IN=0: all OK, IN=1: end of file, IN=-1: error
*/
{
    var nf = this.variables.retrieve("NF", []);
    var name = this.variables.retrieve("NF$", []);
    var mode = (nf%2) ? "w" : "r";
    var device = Math.floor(nf/2);
    var status = this.storage[device].open(name, mode) ? 0 : -1;
    this.variables.assign(status, "IN", []);
}

function subClose()
// GOSUB 540
// Read into IN$ from the opened file NF$ (in IN the status, see line 500)
{
    var nf = this.variables.retrieve("NF", []);
    var device = Math.floor(nf/2);
    var status = this.storage[device].close() ? 0 : -1;
    this.variables.assign(status, "IN", []);
}

function subReadFile()
// GOSUB 560
// Send SR$ towards the opened file NF$ (in IN the status, see line 500)
{
    var nf = this.variables.retrieve("NF", []);
    var device = Math.floor(nf/2);
    var status = 0;
    var str = "";
    try {
        str = this.storage[device].readLine();
        if (str === null) {
            status = 1;
            str = "";
        }
    }
    catch (e) {
        if (typeof e !== "string") throw e;
        status = -1;
    }
    this.variables.assign(status, "IN", []);
    this.variables.assign(str, "IN$", []);
}

function subWriteFile()
// GOSUB 580
// Close the file with code NF
{
    var nf = this.variables.retrieve("NF", []);
    var device = Math.floor(nf/2);
    var status = 0;
    var str = this.variables.retrieve("SR$", []);
    try {
        this.storage[device].writeLine(str);
    }
    catch (e) {
        if (typeof e !== "string") throw e;
        status = -1;
    }
    this.variables.assign(status, "IN", []);
}

function subPlot()
// GOSUB 620
// Plot a point at graphic position HO,VE (0<=HO<1 en 0<=VE<1) in fore/background color CN (=0/1; normally white/black)
{
    subSetColour.call(this);
    var x = this.variables.retrieve("HO", []);
    var y = this.variables.retrieve("VE", []);
    var c = this.variables.retrieve("CN", []);
    this.output.plot(x, y, c);
}

function subDraw()
// GOSUB 630
// Draw a line towards point HO,VE (0<=HO<1 en 0<=VE<1) in fore/background color CN (=0/1; normally white/black)
{
    subSetColour.call(this);
    var x = this.variables.retrieve("HO", []);
    var y = this.variables.retrieve("VE", []);
    var c = this.variables.retrieve("CN", []);
    this.output.draw(x, y, c);
}

function subText()
// GOSUB 650
// Print SR$ as text from graphic position HO,VE (0<=HO<1 en 0<=VE<1). HO and VE stay the same value.
{
    subSetColour.call(this);
    var x = this.variables.retrieve("HO", []);
    var y = this.variables.retrieve("VE", []);
    var text = this.variables.retrieve("SR$", []);
    var c = this.variables.retrieve("CN", []);
    this.output.drawText(x, y, c, text);
}

function subSetColour()
{
    var fg = this.variables.retrieve("CC", [0]);
    var bg = this.variables.retrieve("CC", [1]);
    this.output.foreground = this.output.colours[fg];
    this.output.background = this.output.colours[bg];
}


///////////////////////////////////////////////////////////////////////////////
// screen

var SCALE = 4;

function Display(output_element, columns, rows, font_name, colours)
{
    // only allow one program to connect at a time
    this.busy = false;

    this.width = columns;
    this.height = rows;

    // set the colour palette
    this.colours = colours;
    this.foreground = this.colours[7];
    this.background = this.colours[0];

    // number of ticks in a cursor cycle
    this.cursor_ticks = 640/IDLE_DELAY;

    // resize the canvas to fit the font size
    var context = output_element.getContext("2d");
    var font_height = 8;
    var font_width = 8;

    var glyphs = null;
    if (font_name === "smooth") {
        context.font = font_height*SCALE + "px monospace";
        var measures = context.measureText("M");
        font_width = Math.round(measures.width / SCALE);
    }
    else {
        glyphs = buildFont(font_name);
        font_height = FONTS[font_name].height;
        font_width = FONTS[font_name].width;
    }

    this.pixel_width = font_width * this.width;
    this.pixel_height = font_height*this.height;
    output_element.width = SCALE * this.pixel_width;
    output_element.height = SCALE * this.pixel_height;

    // set the context on the resized canvas
    context = output_element.getContext("2d");
    context.font = "normal lighter "+font_height*SCALE+"px monospace";


    this.acquire = function(do_run)
    // acquire this interface, after the previous user released it
    {
        this.busy = true;
    }

    this.release = function()
    // release this interface
    {
        this.busy = false;
        this.curtain();
        this.resetColours();
    }

    this.resetColours = function()
    {
        this.foreground = this.colours[7];
        this.background = this.colours[0];
    }

    ///////////////////////////////////////////////////////////////////////////
    // primitives

    this.putPixel = function(x, y, c) {
        x = Math.round(x);
        y = Math.round(y);
        context.fillStyle = (c===0) ? this.foreground : this.background;
        context.fillRect(x*SCALE, y*SCALE, SCALE, SCALE);
    }

    this.clearText = function(x, y, output)
    // x,y are (approximate) top left corner of text box, not baseline
    {
        context.fillStyle = this.background;
        x = Math.round(x);
        y = Math.round(y);
        context.fillRect(x*SCALE, y*SCALE, output.length*font_width*SCALE, font_height*SCALE);
    }

    this.putText = function(x, y, c, output)
    // x,y are (approximate) top left corner of text box, not baseline
    {
        x = Math.round(x);
        y = Math.round(y);
        if (font_name !== "smooth") {
            for (var k=0; k < output.length; ++k) {
                var glyph = glyphs[output[k]];
                if (glyph) {
                    for (var i=0; i < glyph.length; ++i) {
                        for (var j=0; j < glyph[i].length; ++j) {
                            if (glyph[i][j]) this.putPixel(x+k*font_width+j, y+i, c);
                        }
                    }
                }
                else {
                    if (output[k]) console.log("Undefined character with code point "+ output[k].charCodeAt(0));
                }
            }
        }
        else {
            context.fillStyle = (c===0) ? this.foreground : this.background;
            // 0.75 seems about the right baseline offset for Chrome & Firefox...
            context.fillText(output, x*SCALE, (y+0.75*font_height)*SCALE);
        }
    }

    this.line = function(x0, y0, x1, y1, c)
    {
        x0 = Math.round(x0);
        y0 = Math.round(y0);
        x1 = Math.round(x1);
        y1 = Math.round(y1);

        // Bresenham algorithm
        var dx = Math.abs(x1-x0);
        var dy = Math.abs(y1-y0);
        var steep = dy > dx;
        if (steep) {
            var tmp = x0;
            x0 = y0;
            y0 = tmp;
            tmp = x1;
            x1 = y1;
            y1 = tmp;
            tmp = dx;
            dx = dy;
            dy = tmp;
        }
        var sx = (x1 > x0) ? 1 : -1;
        var sy = (y1 > y0) ? 1 : -1;
        var line_error = Math.trunc(dx / 2);
        var ry = y0;
        for (var rx = x0; rx*sx <= x1*sx; rx += sx) {
            if (steep) this.putPixel(ry, rx, c);
            else this.putPixel(rx, ry, c);
            line_error -= dy;
            if (line_error < 0) {
                ry += sy;
                line_error += dx;
            }
        }
    }

    this.curtain = function()
    {
        context.fillStyle = "rgba(225,225,225,0.25)";
        context.fillRect(0, 0, output_element.width, output_element.height);
    }

    var cursor_now = 0;
    this.cursor = function()
    {
        cursor_now = (++cursor_now) % this.cursor_ticks;
        if (cursor_now > this.cursor_ticks/2) {
            context.fillStyle = this.foreground;
        }
        else {
            context.fillStyle = this.background;
        }
        context.fillRect(this.col*font_width*SCALE, this.row*font_height*SCALE,
            font_width*SCALE, font_height*SCALE);
    }

    this.clear = function()
    {
        context.fillStyle = this.background;
        context.fillRect(0, 0, output_element.width, output_element.height);
        this.row = 0;
        this.col = 0;
        this.content = (" ".repeat(this.width)+"\n").repeat(this.height).split("\n");
        //graphics
        this.last_x = 0;
        this.last_y = 0;
    }

    this.clearRow = function(row)
    {
        context.fillStyle = this.background;
        context.fillRect(0, row*font_height*SCALE, output_element.width, font_height*SCALE);
        this.content[row] = " ".repeat(this.width);
    }

    this.scroll = function()
    {
        context.drawImage(output_element,
            0, font_height*SCALE, output_element.width, output_element.height-font_height*SCALE,
            0, 0, output_element.width, output_element.height-font_height*SCALE);
        context.fillStyle = this.background;
        context.fillRect(0, output_element.height-font_height*SCALE, output_element.width, font_height*SCALE);
        this.content = this.content.slice(1).concat(" ".repeat(this.width));
    }


    ///////////////////////////////////////////////////////////////////////////
    // text

    this.write = function(output)
    {
        var lines = output.toString().split(/\r?\n/);
        var i=1;
        this.writeRaw(lines[0]);
        for (; i < lines.length; ++i) {
            this.lineFeed();
            this.writeRaw(lines[i]);
        }
    }

    this.checkPos = function()
    {
        if (this.col >= this.width) {
            this.col = 0;
            ++this.row;
        }
        if (this.row >= this.height) {
            this.scroll();
            this.row = this.height-1;
        }
    }

    this.writeRaw = function(output)
    {
        if ((this.row >= this.height) || (this.row<0)) return;

        for (var i=0; i < output.length; ++i) {
            var char = "";
            if (output.charCodeAt(i) === 127) {
                // put a space to clear the cursor
                this.putChar(" ");
                --this.col;
                this.checkPos();
                this.putChar(" ");
            }
            else if (output.charCodeAt(i) >= 32 && output.charCodeAt(i) < 127) {
                this.putChar(output[i]);
                ++this.col;
                this.checkPos();
            }
        }
    }

    this.putChar = function(char)
    {
        this.clearText(this.col*font_width, this.row*font_height, char);
        this.putText(this.col*font_width, this.row*font_height, 0, char);
        // update content buffer
        this.content[this.row] = this.content[this.row].slice(0, this.col) + char + this.content[this.row].slice(this.col+1);
    }

    this.writeCentre = function(row, str)
    // write centred; used by the loader only
    {
        this.setColumn((this.width - str.length)/2);
        this.setRow(row);
        this.write(str);
    }

    this.getScreenChar = function(row, col)
    {
        return this.content[row].slice(col, col+1);
    }

    this.invertColour = function()
    {
        var buf = this.foreground;
        this.foreground = this.background;
        this.background = buf;
    }

    this.setColumn = function(col)
    {
        this.col = col;
        if (this.col >= this.width) this.lineFeed();
    }

    this.lineFeed = function()
    {
        ++this.row;
        this.col = 0;
        if (this.row >= this.height) {
            this.scroll();
            this.row = this.height-1;
        }
    }

    this.setRow = function(row)
    {
        this.row = row;
        if (this.row >= this.height) {
            this.scroll();
            this.row = this.height-1;
        }
    }

    ///////////////////////////////////////////////////////////////////////////
    // graphics

    this.plot = function(x, y, c)
    {
        this.last_x = Math.trunc(x * this.pixel_width);
        this.last_y = Math.trunc(y * this.pixel_height);
        this.putPixel(this.last_x, this.last_y, c);
    }

    this.draw = function(x, y, c)
    {
        var next_x = Math.trunc(x * this.pixel_width);
        var next_y = Math.trunc(y * this.pixel_height);
        this.line(this.last_x, this.last_y, next_x, next_y, c);
        this.last_x = next_x;
        this.last_y = next_y;
    }

    this.drawText = function(x, y, c, text)
    {
        var pixel_x = Math.trunc(x * this.pixel_width);
        var pixel_y = Math.trunc(y * this.pixel_height);
        this.putText(pixel_x, pixel_y, c, text);
    }

    // initialise
    this.resetColours();
    this.clear();
}


///////////////////////////////////////////////////////////////////////////////
// keyboard

function Keyboard(input_element)
{
    // JavaScript to BASICODE keycode dictionary
    var KEYS = {
        8: 127, // backspace
        13: 13, // enter
        37: 28, // left
        38: 31, // up
        39: 29, // right
        40: 30, // down
        112: -1, // F1
        113: -2, // F2
        114: -3, // F3
        115: -4, // F4
        116: -5, // F5
        117: -6, // F6
        118: -7, // F7
        119: -8, // F8
        120: -9, // F9
        121: -10, // F10
        122: -11, // F11
        123: -12, // F12
    }

    var self = this;

    input_element.addEventListener("keydown", function(event) {
        // use this for backspace, function keys
        if (event.keyCode === 19 && event.ctrlKey && !self.suppress_break) {
            self.break_flag = true;
        }
        if (event.keyCode in KEYS) {
            self.buffer.push(KEYS[event.keyCode]);
            // preventDefault will stop all keys from being caught by keypress, so use only for backspace and function keys to avoid browser actions
            event.preventDefault();
        }
    });

    input_element.addEventListener("keypress", function(event) {
        self.buffer.push(event.charCode);
        event.preventDefault();
    });

    // Break key combination has been pressed
    this.break_flag = false;

    this.reset = function()
    {
        this.buffer = [];
        // suppress ctrl+break key
        this.suppress_break = false;
        // break has been pressed
        this.break_flag = false;
        // interactive line buffer
        this.line_buffer = "";
    }

    this.keyPressed = function() {
        return self.buffer.length > 0;
    }

    this.readKey = function()
    {
        if (!this.buffer.length) return 0;
        return this.buffer.shift();
    }

    // INPUT support

    this.interact = function(output)
    {
        output.cursor();
        var loc = this.buffer.indexOf(13);
        var new_chars = [];
        if (loc === -1) {
            new_chars = this.buffer.slice();
            this.buffer = [];
        }
        else {
            new_chars = this.buffer.slice(0, loc);
            // leave the CR out of the buffer
            this.buffer = this.buffer.slice(loc+1);
        }
        var new_str = String.fromCharCode.apply(null, new_chars);
        this.line_buffer += new_str;
        output.write(new_str);
        // echo the newline, but don"t return it
        // also echo a space to remove the cursor (this is a bit of a hack);
        if (loc !== -1) output.write(" \n");
        // trigger value is true if CR has been found
        return (loc !== -1);
    }

    this.readLine = function()
    {
        var line = this.line_buffer;
        this.line_buffer = "";
        // handle backspaces
        for (var i=0; i < line.length;) {
            if (line.charCodeAt(i) === 127) {
                line = line.slice(0, i-1) + line.slice(i+1);
                --i;
            }
            else if (line.charCodeAt(i) < 32 || line.charCodeAt(i) > 126) {
                line = line.slice(0, i) + line.slice(i+1);
            }
            else ++i;
        }
        return line;
    }

    this.reset();
}


///////////////////////////////////////////////////////////////////////////////
// printer

function Printer(element_id) {

    var print_iframe;
    if (element_id) {
        print_iframe = document.getElementById(element_id);
    }
    else {
        // create hidden iframe for printing
        print_iframe = document.createElement("iframe");
        print_iframe.hidden = true;
        document.body.appendChild(print_iframe);
    }
    var print_element = document.createElement("pre");
    print_iframe.contentDocument.body.appendChild(print_element)

    this.write = function(text)
    // add text to the print document
    {
        print_element.textContent += text.split(/\r?\n/).join("\n");
    }

    this.flush = function()
    // send the document (if any) to the printer
    {
        if (print_element.textContent) {
            print_iframe.contentWindow.print();
            print_element.textContent = "";
        }
    }
}


///////////////////////////////////////////////////////////////////////////////
// speaker

function Speaker()
// tone generator
{
    var context = null;
    try {
        var context = AudioContext ? new AudioContext() : null;
    } catch (e) {
        // NotSupportedError if too many contexts opened on one page
        if (e instanceof DOMException) console.log(e);
        else throw e;
    }
    this.tones = 0;

    this.isBusy = function()
    {
        return (this.tones > 0);
    }

    this.sound = function(frequency, duration, volume)
    // play a sound at frequency (Hz) and volume (0--1) for duration (s)
    // caller should check we"re not busy first, otherwise first oscillator to stop
    // will unset the busy flag
    {
        if (!context) return;
        // Oscillator node
        var oscillator = context.createOscillator();
        oscillator.type = "square";
        oscillator.frequency.value = frequency;

        // Gain node
        var gain = context.createGain();
        gain.gain.value = volume;

        // link nodes up
        oscillator.connect(gain);
        gain.connect(context.destination);

        // play the tone
        ++this.tones;
        var now = context.currentTime;
        oscillator.start(now);
        oscillator.stop(now + duration);

        // clean up afterwards
        var speaker = this;
        oscillator.onended = function() {
            // this event seems to be missed by Chromium, occasionally
            --speaker.tones;
            oscillator.disconnect();
            gain.disconnect();
        };
    }
}


///////////////////////////////////////////////////////////////////////////////
// time

function Timer()
{
    var start = null;
    this.duration = 0;

    this.set = function(duration)
    {
        start = new Date();
        this.duration = duration;
    }

    this.clear = function()
    {
        start = null;
        this.duration = 0;
    }

    this.elapsed = function() {
        if (start === null) return true;
        return (new Date() - start) > this.duration;
    }

    this.remaining = function() {
        if (start === null) return 0;
        var remaining = this.duration - (new Date() - start);
        return (remaining<0) ? 0 : remaining;
    }
}


///////////////////////////////////////////////////////////////////////////////
// storage

function Floppy(id, element_id)
{
    var element = null;
    if (element_id) element = document.getElementById(element_id);

    this.id = id;
    this.open_file = null;
    this.open_key = null;
    this.open_mode = "";
    this.open_line = null;

    var mime_type = "text/plain";
    var prefix = "BASICODE"

    // this is where we keep our blobs
    var blobbery = {};

    this.refresh = function()
    {
        if (!element) return;
        while (element.firstChild) {
            element.removeChild(element.firstChild);
        }
        for (var i=0; i < localStorage.length; ++i) {
            var key = localStorage.key(i)
            var key_list = key.split(":");
            if (key_list[0] !== prefix) continue;
            if (key_list[1] !== "" + this.id) continue;
            // create content blob from local storage, if necessary
            if (!(key in blobbery)) {
                blobbery[key] = new Blob([localStorage.getItem(key)], {type: mime_type});
            }
            // create download link to file
            var a = document.createElement("a");
            a.textContent = key_list[2];
            a.href = window.URL.createObjectURL(blobbery[key]);
            a.download = key_list[2];
            // drag-out support
            a.dataset.downloadurl = [mime_type, a.download, a.href].join(":");
            a.draggable = true;
            a.addEventListener("dragstart", function(e) {
                e.dataTransfer.setData("DownloadURL", a.dataset.downloadurl);
            }, false);
            element.appendChild(a);
        }
    }

    this.open = function(name, mode)
    {
        this.open_key = [prefix, this.id, name].join(":");
        var string = localStorage.getItem(this.open_key);
        this.open_mode = mode;
        this.open_line = 0;
        if (string === undefined || string === null) {
            if (this.open_mode === "r") {
                this.open_file = null;
                this.open_key = null;
                return false;
            }
            else {
                this.open_file = [];
            }
        }
        else {
            this.open_file = string.split("\n");
        }
        this.refresh();
        return true;
    }

    this.close = function()
    {
        if (this.open_key === null) return false;
        localStorage.setItem(this.open_key, this.open_file.join("\n"));
        this.open_file = null;
        this.refresh();
        return true;
    }

    this.readLine = function()
    {
        if (this.open_mode !== "r") throw "File not open for read";
        if (this.open_line >= this.open_file.length) return null;
        return this.open_file[this.open_line++];
    }

    this.writeLine = function(line)
    {
        if (this.open_mode !== "w") throw "File not open for write";
        this.open_file.push(line);
    }

    this.refresh();
}


///////////////////////////////////////////////////////////////////////////////
// user interface

var busy_delay = 1;
var IDLE_DELAY = 60;
// minimum delay (nested delays are "clamped" by the browser)
var MIN_DELAY = 4;


function BasicodeApp(script)
{
    // optional target elements
    var screen_id = script.dataset["canvas"];
    var printer_id = script.dataset["printer"];
    var flop1_id = script.dataset["floppy-1"];
    var flop2_id = script.dataset["floppy-2"];
    var flop3_id = script.dataset["floppy-3"];
    var listing_id = script.dataset["listing"];
    // speed setting is (roughly) the number of empty loop cycles per second
    if (script.dataset["speed"]) busy_delay = 1000 / script.dataset["speed"];
    // screen settings
    var columns = script.dataset["columns"] || 40;
    var rows = script.dataset["rows"] || 24;
    var font_name = script.dataset["font"] || "smooth";
    // palette settings, use CGA colours by default
    var colours = {
        0: "black",
        1: "#0000aa", // blue
        2: "#aa0000", // red
        3: "#aa00aa", // purple
        4: "#00aa00", // green
        5: "#00aaaa", // cyan
        6: "#ffff55", // yellow
        7: "white",
    }
    for (var i=0; i<8; ++i) colours[i] = script.dataset["color-" + i] || colours[i];

    // obtain screen/keyboard canvas
    var element;
    if (screen_id) {
        // canvas is provided
        element = document.getElementById(screen_id)
    }
    else {
        // create a canvas to work on
        element = document.createElement("canvas");
        element.className = "basicode";
        element.innerHTML = "To use this interpreter, you need a browser that supports the CANVAS element."
        script.parentNode.insertBefore(element, script);
    }
    // make canvas element focussable to catch keypresses
    element.tabIndex = 1;
    element.focus();

    // set up emulator
    this.display = new Display(element, columns, rows, font_name, colours);
    this.keyboard = new Keyboard(element);
    this.printer = new Printer(printer_id);
    this.speaker = new Speaker();
    this.timer = new Timer();
    this.storage = [new Floppy(0), new Floppy(1, flop1_id), new Floppy(2, flop2_id), new Floppy(3, flop3_id)]
    var listing = document.getElementById(listing_id);

    // runtime members
    this.program = null;
    this.running = null;

    var app = this;

    this.handleError = function(e)
    {
        this.stop();
        this.display.invertColour();
        this.display.clearRow(0);
        this.display.setRow(0);
        this.display.setColumn(0);
        if (e instanceof BasicError) {
            this.display.write(e.message);
            var ln = e.where;
            if ((ln === undefined || ln === null) && this.program !== null) ln = this.program.current_line;
            this.display.write(" in "+ ln +"\n");
            this.display.invertColour();
            if (e.detail) {
                this.display.clearRow(1);
                this.display.clearRow(2);
                this.display.setColumn(0);
                this.display.setRow(1);
                this.display.write(e.detail);
            }
        }
        else {
            this.display.write("EXCEPTION\n")
            this.display.invertColour();
            this.display.clearRow(1);
            this.display.clearRow(2);
            this.display.setColumn(0);
            this.display.setRow(1);
            this.display.write(e);
            console.log(e.stack);
            throw e;
        }
    }

    this.load = function(code)
    // load program, parse to AST, connect to output
    {
        // clear screen
        this.display.clear();
        // reset keyboard buffer
        this.keyboard.reset();
        // show program
        if (listing) listing.value = code;
        try {
            // initialise program object
            this.program = new Program(code);
            this.program.attach(this);
            // show title and description
            this.show();
        } catch (e) {
            this.handleError(e);
        }
    }

    this.show = function()
    // show program title and description
    {
        this.display.invertColour();
        this.display.clearRow(0);
        this.display.writeCentre(0, this.program.title);
        this.display.write("\n\n");
        this.display.invertColour();
        this.display.write(this.program.description);
        this.display.invertColour();
        this.display.clearRow(this.display.height - 1);
        this.display.writeCentre(this.display.height - 1, "-- click to run --");
        this.display.invertColour();
        this.display.curtain();
    }

    this.splash = function()
    // intro screen if nothing was loaded
    {
        if (listing) listing.value = '';
        this.display.invertColour();
        this.display.clearRow(0);
        this.display.writeCentre(0, "(c) 2016, 2017 Rob Hagemans");
        this.display.invertColour();
        var row = 6;
        this.display.writeCentre(row++, "**. .*. .** .*. .** .*. **. ***");
        this.display.writeCentre(row++, "*.* *.* *.. .*. *.. *.* *.* *..");
        this.display.writeCentre(row++, "*.* *.* *.. .*. *.. *.* *.* *..");
        this.display.writeCentre(row++, "*.* *.* *.. .*. *.. *.* *.* *..");
        this.display.writeCentre(row++, "..**..***..*...*..*...*.*.*.*.**...");
        this.display.writeCentre(row++, "*.* *.* ..* .*. *.. *.* *.* *..");
        this.display.writeCentre(row++, "*.* *.* ..* .*. *.. *.* *.* *..");
        this.display.writeCentre(row++, "*.* *.* ..* .*. *.. *.* *.* *..");
        this.display.writeCentre(row++, "**. *.* **. .*. .** .*. **. ***");
        this.display.writeCentre(17, "---==[2017]==---");
        this.display.invertColour();
        this.display.clearRow(this.display.height - 1);
        this.display.writeCentre(this.display.height - 1, "-- drag and drop to load --");
        this.display.invertColour();
        this.display.curtain();
    }

    this.run = function()
    // execute the program
    {
        // exit if nothing loaded
        if (!this.program || this.program.tree === null) return;

        // clear screen
        this.display.clear();
        // reset keyboard buffer
        this.keyboard.reset();
        // reset program state
        this.program.clear();

        var current = this.program.tree;
        var delay = 0;

        function step() {
            try {
                while (true) {
                    if (current instanceof Label && typeof current.label === "number") {
                        app.program.current_line = current.label;
                    }
                    if (current.delay) delay += current.delay;
                    current = current.step();
                    if (!current) {
                        app.stop();
                        break;
                    }
                    if (app.keyboard.break_flag) throw new BasicError("Break", "");
                    if (current && (delay >= MIN_DELAY)) {
                        app.running = window.setTimeout(step, delay);
                        delay = 0;
                        break;
                    }
                };
            } catch (e) {
                app.handleError(e);
            }
        }
        // get started
        this.running = window.setTimeout(step, MIN_DELAY);
    }

    this.stop = function()
    // release resources upon program end
    {
        if (this.running) window.clearTimeout(this.running);
        this.running = null;
        if (this.program !== null) {
            this.display.release();
            this.printer.flush();
        }
        this.display.invertColour();
        this.display.clearRow(this.display.height - 1);
        this.display.writeCentre(this.display.height - 1, "-- click to run again --");
        this.display.invertColour();
    }

    // load & run the code provided in the element, if any
    var url = script.getAttribute("src");
    var code = script.innerHTML;
    if (url !== undefined && url !== null && url) {
        var url = script.getAttribute("src");
        var request = new XMLHttpRequest();
        request.open("GET", url, true);
        request.onreadystatechange = function() {
            if (request.readyState === 4 && request.status === 200) {
                app.load(request.responseText);
            }
        }
        request.send(null);
    }
    else if (code) {
        this.load(code);
    }
    else {
        this.splash();
    }


    ///////////////////////////////////////////////////////////////////////////
    // event handlers

    if (listing) {
        var last_code = listing.value;

        // reload code if listing changes
        listing.onblur = function() {
            if (listing.value === last_code) return;
            last_code = listing.value;
            app.stop();
            app.load(listing.value);
        }
    }
    // run file on click

    element.addEventListener("click", function click(e) {
        if (!app.running) app.run();
    });

    // load files on drag & drop

    element.addEventListener("dragenter", function dragenter(e) {
        e.stopPropagation();
        e.preventDefault();
    });

    element.addEventListener("dragover", function dragover(e) {
        e.stopPropagation();
        e.preventDefault();
    });

    element.addEventListener("drop", function drop(e) {
        e.stopPropagation();
        e.preventDefault();
        var files = e.dataTransfer.files;
        var reader = new FileReader();
        reader.onload = function() {
            app.stop();
            app.load(reader.result);
        };
        reader.readAsText(files[0]);
    });

}

function launch() {
    var scripts = document.getElementsByTagName("script");
    for(var i=0; i < scripts.length; ++i) {
        if (scripts[i].type == "text/basicode") {
            var app = new BasicodeApp(scripts[i]);
        }
    }
}
// a bit of magic to run launcher() after the document is complete
// so that it can access all the <script> tags
// http://stackoverflow.com/questions/807878/javascript-that-executes-after-page-load
function downloadJSAtOnload() {
    var element = document.createElement("script");
    element.innerHTML = "launch();";
    document.body.appendChild(element);
}
if (window.addEventListener) {
    window.addEventListener("load", downloadJSAtOnload, false);
}
else if (window.attachEvent) {
    window.attachEvent("onload", downloadJSAtOnload);
}
else {
    window.onload = downloadJSAtOnload;
}
